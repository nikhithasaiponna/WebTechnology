//kdm01 - bring custom code in from 5.10 to 5.13 base code for HCM82388
//kdm02 - upgrade custom code to work in 5.13.0.532 - the customizations allow an htmleditor field type for performance review questions.

Ext.namespace('Shr.WebControls');
Ext.namespace('Shr.Util');
Ext.namespace('Shr.panels');

Ext.define('App.overrides.Trigger', {
    override: 'Ext.form.trigger.Trigger',
    onClick: function () {
        var me = this,
            args = arguments,
            e = me.clickRepeater ? args[1] : args[0],
            handler = me.handler,
            field = me.field;
        if (handler && (!field.readOnly || !me.hideOnReadOnly) && me.isFieldEnabled()) {
            Ext.callback(me.handler, me.scope, [field, me, e], 0, field);
        }
    }
});

function getFormValues(formName) {
    var form = document.getElementById(formName);
    var values = {};
    if (!form || form.nodeName !== "FORM") {
        return;
    }
    var i, j, q = [];
    for (i = form.elements.length - 1; i >= 0; i = i - 1) {
        if (form.elements[i].name === "") {
            continue;
        }
        switch (form.elements[i].nodeName) {
            case 'INPUT':
                switch (form.elements[i].type) {
                    case 'text':
                    case 'hidden':
                    case 'password':
                    case 'button':
                    case 'reset':
                    case 'submit':
                        values[form.elements[i].name] = form.elements[i].value;
                        break;
                    case 'checkbox':
                    case 'radio':
                        if (form.elements[i].checked) {
                            values[form.elements[i].name] = form.elements[i].value;
                        }
                        break;
                }
                break;
            case 'file':
                break;
            case 'TEXTAREA':
                values[form.elements[i].name] = form.elements[i].value;
                break;
            case 'SELECT':
                switch (form.elements[i].type) {
                    case 'select-one':
                        values[form.elements[i].name] = form.elements[i].value;
                        break;
                    case 'select-multiple':
                        for (j = form.elements[i].options.length - 1; j >= 0; j = j - 1) {
                            if (form.elements[i].options[j].selected) {
                                values[form.elements[i].name] = form.elements[i].value;
                            }
                        }
                        break;
                }
                break;
            case 'BUTTON':
                switch (form.elements[i].type) {
                    case 'reset':
                    case 'submit':
                    case 'button':
                        values[form.elements[i].name] = form.elements[i].value;
                        break;
                }
                break;
        }
    }
    //return q.join("&");
    return values;
}


Ext.define('Shr.WebControls.Dialog', {
    extend: 'Ext.Component',
    DEFAULT_PAGE_URL: '/API/ControlFetcher.aspx',
    dialogWindow: null,
    sourceControl: null,
    modal: true,
    title: '',
    width: null,
    height: null,
    resizable: false,
    urlParams: null,
    showOkCancel: false,
    showOnHover: false,
    newWindow: false,
    windowName: null,
    refreshOnClose: false,
    doPostBackOnClose: false,
    updateOnCancel: false,
    whiteBackground: true,
    destroyContentOnClose: false,
    destroyOnClose: true,
    
    showImmediate: true,
    destroyOnUpdate: true,
    showPrint: false,
    pageUrl: null,
    closeFn: null,
    url: null,
    requestMethod: 'GET',
    postParams: null,
    closeOnUpdate: null,

    // button text values set during initComponent to ensure language has been set
    okText: '',
    cancelText: '',
    printText: '',
    closeText: '',
    hasModalPopupWithGridWithTriggerFields: false,
    taskInProgress: false,
    initComponent: function () {
        var ptr = this;

        Shr.WebControls.Dialog.superclass.initComponent.call(this);

        var urlRegExp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/
        var urlSlashPrefix = /^\//
        if (Ext.isEmpty(this.pageUrl, false))
            this.url = getLocationRoot() + this.DEFAULT_PAGE_URL;
        else if (urlRegExp.test(this.pageUrl))
            this.url = this.pageUrl;
        else if (urlSlashPrefix.test(this.pageUrl))
            this.url = getLocationRoot() + this.pageUrl;
        else
            this.url = getLocationRoot() + '/' + this.pageUrl;

        if (this.showOnHover) {
            // TODO: Implement showOnHover logic by attaching to this.el
        }

        // Set button text now that language context has been set.
        // Previously we set this when the member variable was declared
        // but we found that the language context was not always set in
        // time, so we are moving it here when the control is initialized

        // but we do want to get the values if they are set elsewhere
        ptr.okText = this.okText == '' ? Ext.MessageBox.buttonText.ok : this.okText;
        ptr.cancelText = this.cancelText == '' ? Ext.MessageBox.buttonText.cancel : this.cancelText;
        ptr.printText = this.printText == '' ? Shr.LABEL_Print : this.printText;
        ptr.closeText = this.closeText == '' ? Shr.LABEL_Close : this.closeText;
    },

    show: function () {
        this.taskInProgress = true;
        if (this.width == 'max') {
            this.width = this.newWindow ? screen.height - 75 : Ext.Element.getViewportWidth() - 75;
        } else if (this.width == null || this.width == '') {
            this.width = this.newWindow ? screen.width * .4 : Ext.Element.getViewportWidth() * .4;
        }
        if (this.height == 'max') {
            this.height = this.newWindow ? screen.height - 75 : Ext.Element.getViewportHeight() - 75;
        } else if (this.height == null || this.height == '') {
            this.height = screen.height * .4;
        }

        var ptr = this;

        if (this.newWindow) {
            //logic to center the new window, even with dual monitors
            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;

            var auxWidth = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
            var auxHeight = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

            var left = ((auxWidth / 2) - (this.width / 2)) + dualScreenLeft;
            var top = ((auxHeight / 2) - (this.height / 2)) + dualScreenTop;

            var resizeableStr = this.resizable ? '1' : '0';
            var winParams = 'menubar=0,location=0,status=0,scrollbars=1,resizable=' + resizeableStr
                + ',left=' + left
                + ',top=' + top
                + ',width=' + this.width
                + ',height=' + this.height;

            var url = this.url
                + (!Ext.isEmpty(this.sourceControl, false) ? '?source=' + this.sourceControl : '?')
                + '&' + this.urlParams
                + '&rnd=' + Math.random()
                + '&fullpage=true&title=' + this.title;
            this.dialogWindow = window.open(url, this.windowName, winParams);
            if (this.modal) {
                window.onfocus = function () {
                    if (ptr.dialogWindow && !ptr.dialogWindow.closed) {
                        ptr.dialogWindow.focus();
                    } else if (ptr.dialogWindow) {
                        ptr.dialogWindow = null;
                        window.onfocus = null;
                        ptr.close();
                    }
                };
                this.dialogWindow.onload = function () {
                    try {
                        this.dialogWindow.focus();
                    } catch (err) { }
                };
            }
        } else {
            var style = 'height:100%; overflow:auto;';

            if (this.whiteBackground) {
                style += 'background-color:white;';
            }
            this.contentEl = Ext.getBody().createChild({
                tag: 'div',
                style: style
            });

            if (!this.showImmediate) {
                this.contentEl.hide();
            }

            // Remember the original __doPostBack function, because when we
            // load the new ASP.NET page, it'll overwrite it with a new one!
            if (typeof __doPostBack != 'undefined') {
                this.originalDoPostBackFn = __doPostBack;
            }


            //Ext 6.0 new way to show loading while loading content.
            var myLoadMask = new Ext.LoadMask({
                componentCls: 'popup-loading',
                target: this.contentEl
            });

            this.contentEl.load({
                url: this.url
                    + (!Ext.isEmpty(this.sourceControl, false) ? '?source=' + this.sourceControl : '?')
                    + '&ComponentId=' + this.id
                    + ((this.requestMethod === 'GET') ? '&' + this.urlParams : ''),
                method: this.requestMethod,
                params: this.requestMethod === 'GET' ? this.urlParams : this.postParams,
                scripts: true,
                text: Ext.form.field.ComboBox.prototype.loadingText,
                callback: function (el, success, response, options) {
                    // After the page is loaded, restore the original __doPostBack
                    // function, so the page and ASP.NET AJAX will function properly.
                    // We also need to restore the form target for the postbacks to
                    // the main form on the document, not the form on the picker page.

                    if (typeof __doPostBack != 'undefined') {
                        __doPostBack = ptr.originalDoPostBackFn;
                    }
                    theForm = document.forms['aspnetForm'];

                    //var height = document.getElementById(ptr.contentEl.id).firstChild.offsetHeight;

                    //IE as usual, doing strange stuff, tend to crop the popups
                    //by adding the scroll bar to the right.
                    if (Ext.isIE) {
                        ptr.dialogWindow.setWidth(ptr.dialogWindow.width + 30);
                    }

                    if (!ptr.showImmediate) {
                        ptr.dialogWindow.setTitle(ptr.title);
                        ptr.contentEl.show();
                        ptr.dialogWindow.show();
                        if (Ext.isIE) {
                            ptr.dialogWindow.setWidth(ptr.width + 20);
                            ptr.dialogWindow.center();
                        }
                    }
                }
            });

            // Create buttons here
            var buttons = null;
            if (this.showPrint) {
                if (!this.showOnHover && this.showOkCancel) {
                    buttons = [
                    { text: ptr.printText, iconCls: 'x-fa fa-print', handler: function () { printElement(ptr.contentEl.id) } },
                    { text: ptr.okText, iconCls: 'x-fa fa-check', handler: function () { ptr.update('OK'); } },
                    { text: ptr.cancelText, iconCls: 'x-fa fa-ban', handler: function () { if (ptr.updateOnCancel) ptr.update('CANCEL'); else ptr.close(); } }
                ];
                } else if (!this.showOnHover) {
                    buttons = [
                        { text: ptr.printText, iconCls: 'x-fa fa-print', handler: function () { printElement(ptr.contentEl.id) } },
                        { text: ptr.closeText, iconCls: 'x-fa fa-times', handler: function () { ptr.close(); } }
                ];
                }
            } else {
                if (!this.showOnHover && this.showOkCancel) {
                    buttons = [
                        { text: ptr.okText, iconCls: 'x-fa fa-check', handler: function () { ptr.update('OK'); } },
                        { text: ptr.cancelText, iconCls: 'x-fa fa-ban', handler: function () { if (ptr.updateOnCancel) ptr.update('CANCEL'); else ptr.close(); } }
                    ];
                } else if (!this.showOnHover) {
                    buttons = [{ text: ptr.closeText, iconCls: 'x-fa fa-times', handler: function () { ptr.close(); } }];
                }
            }

            //if the height is 'auto' and we add 20 to it, JS writes the height as
            // auto20, which fails with NaN later down the road (SCR 60816)
            var dwHeight;
            if (isNaN(this.height)) {
                dwHeight = this.height;
            } else {
                dwHeight = this.height + 20;
            }


            this.dialogWindow = Ext.create('Ext.window.Window', {
                contentEl: this.contentEl,
                width: this.width + 20,
                height: dwHeight,
                resizable: this.resizable,
                closable: !this.showOnHover,
                modal: this.modal,
                title: this.title,
                buttons: buttons,
                layout: 'fit',
                floating: true,
                fixed: true,
                hasModalPopupWithGridWithTriggerFields: this.hasModalPopupWithGridWithTriggerFields
            });

            if (this.showImmediate) {
                this.dialogWindow.show();
            }

            this.dialogWindow.on('close', this.close, this);
        }
    },

    update: function (action) {
        // If the user hits <enter> then 'action == 13'
        if (action == 13) {
            action = 'OK';
        }

        var params = this.getValues();

        // Remember the original __doPostBack function, because when we
        // load the new ASP.NET page, it'll overwrite it with a new one!
        if (typeof __doPostBack != 'undefined') {
            this.originalDoPostBackFn = __doPostBack;
        }

        this.contentEl.setHeight(this.contentEl.getSize().height);
        this.contentEl.setWidth(this.contentEl.getSize().width);

        // Release resources for child components in the dialog.
        if (this.destroyOnUpdate)
            this.destroyChildren();

        if (this.updateManager == null || typeof (this.updateManager) === 'undefined') {
            this.updateManager = new Ext.ElementLoader(this.contentEl);

            //Ext 6.0 new way to show loading while loading content.
            this.updateManager.loadMask = new Ext.LoadMask({
                componentCls: 'popup-loading',
                target: this.dialogWindow.contentEl
            });


            this.updateManager.method = 'POST';
            // We need to extend the 30 second default so that 
            // tasks such as timesheet summary mass approval do not timeout.
            this.updateManager.timeout = 300;
        }


        var ptr = this;
        this.updateManager.load({
            url: this.url
                + (!Ext.isEmpty(this.sourceControl, false) ? '?source=' + this.sourceControl : '?')
                + '&ComponentId=' + this.id
                + '&' + this.urlParams
                + '&Action=' + action,
            params: params,
            scripts: true,
            callback: function (el, success, response, options) {
                // After the callback completes, restore the original __doPostBack
                // function, so the page and ASP.NET AJAX will function properly.
                // We also need to restore the form target for the postbacks to
                // the main form on the document, not the form on the picker page.
                __doPostBack = ptr.originalDoPostBackFn;
                theForm = document.forms['aspnetForm'];

                //The code below is a special case for open enrollment editing popup
                //It needs to determine if the popup has errors, but the actual determination
                //is on the server AFTER the popup closes.  So, we need to check for a flag
                //which was set in the page.
				if (response != undefined) {
					var responseData = response.responseText;
					if (responseData.search('OESummaryHasErrors') > 0)
					{
						return;
					}
				}
                if ((action == 'CANCEL') || (ptr.closeOnUpdate)) {

                    ptr.close();
                }
            }
        });
    },
    getValues: function () {
        var formName = this.sourceControl.replace(/[^-_$A-Za-z0-9]+/g, '_'); // replace non-alpha
        var form = document.getElementById(Shr.WebControls.Dialog.POPUP_FORM_ID + formName);
        var values = {};
        if (!form || form.nodeName !== "FORM") {
            return;
        }
        var i, j, q = [];
        for (i = form.elements.length - 1; i >= 0; i = i - 1) {
            if (form.elements[i].name === "") {
                continue;
            }
            switch (form.elements[i].nodeName) {
                case 'INPUT':
                    switch (form.elements[i].type) {
                        case 'text':
                        case 'hidden':
                        case 'password':
                        case 'button':
                        case 'reset':
                        case 'submit':
                            values[form.elements[i].name] = form.elements[i].value;
                            break;
                        case 'checkbox':
                        case 'radio':
                            if (form.elements[i].checked) {
                                values[form.elements[i].name] = form.elements[i].value;
                            }
                            break;
                    }
                    break;
                case 'file':
                    break;
                case 'TEXTAREA':
                    values[form.elements[i].name] = form.elements[i].value;
                    break;
                case 'SELECT':
                    switch (form.elements[i].type) {
                        case 'select-one':
                            values[form.elements[i].name] = form.elements[i].value;
                            break;
                        case 'select-multiple':
                            for (j = form.elements[i].options.length - 1; j >= 0; j = j - 1) {
                                if (form.elements[i].options[j].selected) {
                                    values[form.elements[i].name] = form.elements[i].value;
                                }
                            }
                            break;
                    }
                    break;
                case 'BUTTON':
                    switch (form.elements[i].type) {
                        case 'reset':
                        case 'submit':
                        case 'button':
                            values[form.elements[i].name] = form.elements[i].value;
                            break;
                    }
                    break;
            }
        }
        //return q.join("&");
        return values;
    },
    setTitle: function (title) {
        if (this.title == title)
            return;

        this.title = title;
        if (this.dialogWindow != null) {
            this.dialogWindow.setTitle(title);
        }
    },

    setWidth: function (width) {
        if (this.width == width)
            return;

        this.width = width;
        if (this.dialogWindow != null) {
            this.dialogWindow.setWidth(width);
        }
    },

    setHeight: function (height) {
        if (this.height == height)
            return;

        this.height = height;
        if (this.dialogWindow != null) {
            this.dialogWindow.setHeight(height);
        }
    },

    close: function (refreshWindow) {
        if (this.hoverTimer != null) {
            clearTimeout(this.hoverTimer);
            this.hoverTimer = null;
        }
        if (this.dialogWindow == null) {
            if (this.closeFn) {
                this.closeFn();
            }
            return;
        }
        if (this.newWindow) {
            this.dialogWindow = null;
        } else {
            // Release resources for child components in the dialog.
            if (this.destroyContentOnClose == true) {
                this.destroyChildren();
            }

            if (this.contentEl != null) {
                Shr.destroyPanelComponents(this.contentEl.id, false);
                this.contentEl.remove();
                this.contentEl = null;
            }

            this.dialogWindow.hide();
            this.dialogWindow.destroy();
            this.dialogWindow = null;

            this.updateManager = null;

            if (this.refreshOnClose || refreshWindow == true) {
                // We want to redisplay the same page location so that the page will refresh to
                // reflect the latest state of the data.  We do this in case an action that the
                // user took while working within the pop-up should trigger this to happen.
                // To prevent TaskExecute from forcing a postback (and saving the current grid
                // data on a navigation action) tell it to suppress the navigation postback.
                TaskExecute.suppressNavigatePostback();
                document.location.reload();
            }
        }

        if (this.closeFn) {
            this.closeFn();
        }

        if (this.destroyOnClose) {
            this.destroy();
        }

        if (this.doPostBackOnClose) {
            TaskExecute.suppressNavigatePostback();
            __doPostBack();
        }

        //Because some controls could change the way _doPostBack behave example: <asp:Linkbutton> , we need to re validate the originalDoPostBackFn before closing the task.
        if (this.originalDoPostBackFn) {
            __doPostBack = this.originalDoPostBackFn;
        }

        this.taskInProgress = false;
    },

    destroyChildren: function () {
        // Destroy all components within the popup window being updated. Ext does
        // not automatically clean up components within an updated region, so this
        // must be done explicitly by finding components within the content area
        // and destroying them to release their resources.
        
        //We are no longer doing the code below because Ext 6.0  does cleanup the pop-up components (see Ext.override(Ext.Component... in ivantage-ext.js)
        //IE has additional issues if we execute the code as well.
        //Shr.destroyPanelComponents(this.contentEl.id, false);

        // To complete the cleanup and make sure the browser correctly detects
        // DOM objects that were removed, unhook various event handlers from all
        // elements within the dialog update region.
        this.contentEl.select('*', true).each(function (childEl) {
            childEl.onclick = null;
            childEl.onchange = null;
            childEl.clearListeners(); // added for EXT 6.0
        });
    }
});

Ext.define('Shr.WebControls.TextDialog', {
    extend: 'Ext.button.Button',
    dialogWindow: null,
    modal: true,
    dialogHeight: '',
    dialogWidth: '',
    newWindow: true,
    postbackCommand: '',
    title: '',

    // Button text values set during initComponent to ensure language has been set
    submitText: 'Submit',
    closeText: Shr.LABEL_Close,

    listeners: {
        'click': function () {
            this.show();
        }
    },

    show: function () {

        var ptr = this;

        // Create pop-up dialog buttons 
        var dialogButtons = [{
            text: this.submitText,
            handler: function (result) {
                Ext.get(ptr.resultFieldId).dom.value = Ext.get(ptr.textFieldId).dom.value;
                eval(ptr.postbackCommand);
                ptr.dialogWindow.close();
            }
        },
        {
            text: this.closeText,
            handler: function () {
                ptr.dialogWindow.hide();
            }
        }];

        // Create pop-up dialog 
        if (this.dialogWindow == null) {
            this.dialogWindow = Ext.create('Ext.window.Window', {
                contentEl: this.dialogContentEl,
                width: this.dialogWidth,
                height: this.dialogHeight,
                layout: 'fit',
                resizable: this.resizable,
                autoScroll: false,
                modal: this.modal,
                floating: true,
                fixed: true,
                title: this.title,
                buttons: dialogButtons,
                closable: false
            });
        }

        this.dialogWindow.show();

        this.dialogWindow.on('close', this.close, this);
    },

    onDestroy: function () {
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);

        //We need to explicitly destroy the label component otherwise we get a duplicate component error once the submit button is pressed
        var cmp = Ext.ComponentManager.get('PanelDisplayPanel_LicenseInfoPanel_ChangeLicenseKey_Text_extCmp')
        if (cmp != null)
        {
            cmp.destroy();
        }
    },

    close: function (refreshWindow) {

        if (this.dialogWindow == null) return;

        if (this.dialogWindow.contentEl != null) {
            this.dialogWindow.contentEl = null;
        }

        this.dialogWindow.hide();
    }

});
Shr.WebControls.Dialog.POPUP_FORM_ID = "controlForm_";


Ext.define('Shr.WebControls.Field', {
    extend: 'Ext.form.field.Base',

    listeners: {
        'render': function (field, options) {
            if (this.inputEl != null) {
                var onChange = this.inputEl.dom.onchange;
                if (onChange != null) {
                    this.inputEl.dom.onchange = null;
                    this.on('change', function () { eval(onChange); }, this);
                }
            }
        }
    }
});

Ext.define('Shr.WebControls.ListSelect', {
    extend: 'Shr.WebControls.Field',
    hiddenField: null,
    hiddenSort: null,
    leftList: null,
    rightList: null,
    addButton: null,
    addAllButton: null,
    moveUpButton: null,
    moveDownButton: null,
    removeButton: null,
    removeAllButton: null,
    sortable: false,
    initComponent: function () {

        Shr.WebControls.ListSelect.superclass.initComponent.call(this);

        this.hiddenField = Ext.get(this.elId + Shr.WebControls.ListSelect.HIDDEN_FIELD);
        this.hiddenSort = Ext.get(this.elId + Shr.WebControls.ListSelect.HIDDEN_SORT);
        this.leftList = Ext.get(this.elId + Shr.WebControls.ListSelect.LEFT_LIST);
        this.leftList.addListener('dblclick', this.addSelected, this);

        this.rightList = Ext.get(this.elId + Shr.WebControls.ListSelect.RIGHT_LIST);
        this.rightList.addListener('dblclick', this.removeSelected, this);

        this.addButton = Ext.get(this.elId + Shr.WebControls.ListSelect.ADD_BUTTON);
        this.addButton.addListener('click', this.addSelected, this);
        this.addAllButton = Ext.get(this.elId + Shr.WebControls.ListSelect.ADD_ALL_BUTTON);
        this.addAllButton.addListener('click', this.addAll, this);
        this.removeButton = Ext.get(this.elId + Shr.WebControls.ListSelect.REMOVE_BUTTON);
        this.removeButton.addListener('click', this.removeSelected, this);
        this.removeAllButton = Ext.get(this.elId + Shr.WebControls.ListSelect.REMOVE_ALL_BUTTON);
        this.removeAllButton.addListener('click', this.removeAll, this);

        if (this.sortable) {
            this.moveUpButton = Ext.get(this.elId + Shr.WebControls.ListSelect.MOVE_UP_BUTTON);
            this.moveUpButton.addListener('click', this.moveUp, this);
            this.moveDownButton = Ext.get(this.elId + Shr.WebControls.ListSelect.MOVE_DOWN_BUTTON);
            this.moveDownButton.addListener('click', this.moveDown, this);
        }
        this.el = Ext.get(this.elId);
        this.enableButtons();
    },

    getValue: function () {
        return this.hiddenField != null ? this.hiddenField.dom.value : null;
    },

    updateValue: function () {
        if (this.hiddenField != null) {
            var selectedValues = new Array();
            for (var i = 0; i < this.rightList.dom.options.length; i++) {
                selectedValues.push(this.rightList.dom.options[i].value);
            }
            this.hiddenField.dom.value = selectedValues;
        }

        this.enableButtons();
        this.fireEvent('change', this);

        if (this.onUpdate) {
            this.onUpdate(this);
        };

        if (this.autoPostBack) {
            __doPostBack();
        }
    },

    addSelected: function () {
        if (this.warnOnAdd) {
            var ptr = this;
            Ext.Msg.show({
                title: this.addWarningTitle,
                msg: this.addWarningMessage,
                buttons: Ext.Msg.OKCANCEL,
                fn: function (btn, text) {
                    if (btn == 'ok') {
                        ptr.doAdd(true);
                    }
                },
                icon: Ext.MessageBox.QUESTION
            });
        }
        else {
            this.doAdd(false);
        }
    },

    removeSelected: function () {
        if (this.warnOnRemove) {
            var ptr = this;
            Ext.Msg.show({
                title: this.removeWarningTitle,
                msg: this.removeWarningMessage,
                buttons: Ext.Msg.OKCANCEL,
                fn: function (btn, text) {
                    if (btn == 'ok') {
                        ptr.doRemove(false);
                    }
                },
                icon: Ext.MessageBox.QUESTION
            });
        }
        else {
            this.doRemove(false);
        }
    },

    addAll: function () {
        if (this.warnOnAdd) {
            var ptr = this;
            Ext.Msg.show({
                title: this.addWarningTitle,
                msg: this.addWarningMessage,
                buttons: Ext.Msg.OKCANCEL,
                fn: function (btn, text) {
                    if (btn == 'ok') {
                        ptr.doAdd(true);
                    }
                },
                icon: Ext.MessageBox.QUESTION
            });
        }
        else {
            this.doAdd(true);
        }
    },

    removeAll: function () {
        if (this.warnOnRemove) {
            var ptr = this;
            Ext.Msg.show({
                title: this.removeWarningTitle,
                msg: this.removeWarningMessage,
                buttons: Ext.Msg.OKCANCEL,
                fn: function (btn, text) {
                    if (btn == 'ok') {
                        ptr.doRemove(true);
                    }
                },
                icon: Ext.MessageBox.QUESTION
            });
        }
        else {
            this.doRemove(true);
        }
    },

    doRemove: function (removeAll) {
        if (!removeAll) {
            while (this.rightList.dom.selectedIndex != -1) {
                var option = this.rightList.dom.options[this.rightList.dom.selectedIndex];
                this.rightList.dom.remove(this.rightList.dom.selectedIndex);

                option.selected = false;
                this.leftList.dom.options.add(option);
            }
        } else {
            while (this.rightList.dom.options.length > 0) {
                var option = this.rightList.dom.options[0];
                this.rightList.dom.remove(0);
                this.leftList.dom.options.add(option);
            }
        }
        this.updateValue();
    },

    doAdd: function (addAll) {
        if (!addAll) {
            while (this.leftList.dom.selectedIndex != -1) {
                var selectedOption = this.leftList.dom.options[this.leftList.dom.selectedIndex];
                this.leftList.dom.remove(this.leftList.dom.selectedIndex);

                selectedOption.selected = false;
                this.rightList.dom.options.add(selectedOption);
            }
        } else {
            while (this.leftList.dom.options.length > 0) {
                var option = this.leftList.dom.options[0];
                this.leftList.dom.remove(0);
                this.rightList.dom.options.add(option);
            }
        }
        this.updateValue();
    },
    moveUp: function () {
        var selectionsArray = this.selectedOptions();

        //check if the selection is on top, if so do nothing
        for (var i = 0; i < selectionsArray.length; i++) {
            if (selectionsArray[i].index == 0) {
                return;
            }
        }


        for (var i = 0; i < selectionsArray.length; i++) {
            var selectedOption = selectionsArray[i];
            this.rightList.dom.options.add(selectedOption, selectedOption.index - 1);
        }
        this.hiddenSort.dom.value = true;
        this.updateValue();
    },
    moveDown: function () {
        var selectionsArray = this.selectedOptions();

        //check if the selection reaches bottom, if so do nothing
        for (var i = 0; i < selectionsArray.length; i++) {
            if (selectionsArray[i].index == this.rightList.dom.options.length-1) {
                return;
            }
        }

        var selectedIndexes = new Array();
        for (var i = 0; i < selectionsArray.length; i++) {
            selectedIndexes.push(selectionsArray[i].index);
        }
        selectedIndexes.reverse();

        for (var i = 0; i < selectedIndexes.length; i++) {

            var tempOption = this.rightList.dom.options[selectedIndexes[i] + 1];
            var moveOption = this.rightList.dom.options[selectedIndexes[i]];
            this.rightList.dom.options.remove(selectedIndexes[i]);
            this.rightList.dom.options.add(moveOption, this.rightList.dom.options[selectedIndexes[i] + 1]);
        }
        this.hiddenSort.dom.value = true;
        this.updateValue();
    },
    enableButtons: function () {
        this.addButton.dom.disabled = (this.leftList.dom.length > 0 ? false : true);
        this.addAllButton.dom.disabled = (this.leftList.dom.length > 0 ? false : true);
        this.removeButton.dom.disabled = (this.rightList.dom.length > 0 ? false : true);
        this.removeAllButton.dom.disabled = (this.rightList.dom.length > 0 ? false : true);
        if (this.sortable) {
            this.moveUpButton.dom.disabled = (this.rightList.dom.length > 0 ? false : true);
            this.moveDownButton.dom.disabled = (this.rightList.dom.length > 0 ? false : true);
        }
    },
    selectedOptions: function () {
        var selectionsArray = new Array();
        for (var i = 0; i < this.rightList.dom.options.length; i++) {
            if (this.rightList.dom.options[i].selected == true) {
                selectionsArray.push(this.rightList.dom.options[i]);
            }
        }
        return selectionsArray;
    }
});

Shr.WebControls.ListSelect.HIDDEN_FIELD = '_HiddenField';
Shr.WebControls.ListSelect.HIDDEN_SORT = '_HiddenSort';
Shr.WebControls.ListSelect.LEFT_LIST = '_LeftList';
Shr.WebControls.ListSelect.RIGHT_LIST = '_RightList';
Shr.WebControls.ListSelect.ADD_BUTTON = '_AddButton';
Shr.WebControls.ListSelect.ADD_ALL_BUTTON = '_AddAllButton';
Shr.WebControls.ListSelect.REMOVE_BUTTON = '_RemoveButton';
Shr.WebControls.ListSelect.REMOVE_ALL_BUTTON = '_RemoveAllButton';
Shr.WebControls.ListSelect.MOVE_UP_BUTTON = '_MoveUpButton';
Shr.WebControls.ListSelect.MOVE_DOWN_BUTTON = '_MoveDownButton';

//AutoNumber Field
Ext.define('Shr.WebControls.AutoNumberField', {
    extend: 'Ext.form.field.Text',

    onchange: null,
    triggerAction: 'all',
    sourceClass: null,
    sourceProperty: null,
    defaultValue: null,
    draftId: null,
    disabledCls: 'shr-disabled',
    regex: null,
    regexText: null,
    msgTarget: 'side',
    //these last three are needed to hide the default label
    labelWidth: 0,
    labelPad: 0,
    labelCls: '',
    triggers: {
        triggerAdd: {
            cls: 'x-form-trigger fa-plus',
            handler: 'onTriggerAddClick',
            scope: 'this'
        },
        triggerClear: {
            cls: 'x-form-clear-trigger',
            handler: 'onTriggerClearClick',
            scope: 'this'
        }
    },
    onTriggerAddClick: function () {
        var triggerField = this;
        Ext.Ajax.request({
            url: 'API/JsonFetcher.svc/Invoke',
            params: {
                svcprovider: 'JsGetAutoNumber',
                sourceProperty: this.sourceProperty,
                draftId: this.draftId
            },
            success: function (response, options) {
                var result = Ext.decode(response.responseText);
                triggerField.setValue(result.number);
            },
            failure: function (response, options) {
                Ext.MessageBox.alert(Shr.LABEL_Failed, Shr.LABEL_UnableToGenerateAutoNumber);
            }
        });
    },
    onTriggerClearClick: function () { this.setValue(); },
    onDestroy: function () {
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    },
    listeners: {
        change: function (ctl, newValue, oldValue, eOpts) {
            var me = ctl;
            if (me.onchange) {
                me.onchange();
            }
        },
        blur: function (ctl, event, eOpts) {
            var me = ctl,
                value = me.getValue();
            if (value != '' && me.startValue != value && me.lastQuery != value && me.isValid()) {
                me.getTrigger('triggerClear').show();
                setTimeout(Ext.bind(this.doPendingSearch, me), 150);
            }
        }
    }
});



////////////////// START DATE PICKER CONTROLS //////////////////

/*  We are no longer using this code because we DO want the Today button
//override the functionality of the Today button to make it the Close button
Ext.override(Ext.picker.Date, {
    todayText: Shr.LABEL_Close,
    selectToday: function () {
        this.hide();
    }
});
*/
/////////////////////////////////////////////////////////////
// --- A combination of date and time
Ext.define('Ext.picker.DateTime', {
extend: 'Ext.picker.Date',
alias: 'widget.sysdatetimepicker',
    focusable: false,
    editable: true,
    renderTpl: [
        '<div id="{id}-innerEl" data-ref="innerEl" role="presentation">',
        '<center  class="{baseCls}-footer">',
        '<table id="{id}-timeEl" data-ref="timeEl" style="width:100%; padding:0px 5px;" cellspacing="0">',
          '<tbody>',
            '<tr>',
              '<td >{%this.renderTimeLabel(values,out)%}</td>',
              '<td >{%this.renderTimePickerBtn(values,out)%}</td>',
              '<td >{%this.renderTodayBtn(values, out)%}</td>',
            '</tr>',
          '</tbody>',
        '</table>',
        '</center>',
        '<div class="{baseCls}-header">',
        '<div id="{id}-prevEl" data-ref="prevEl" class="{baseCls}-prev {baseCls}-arrow" role="presentation" title="{prevText}"></div>',
        '<div id="{id}-middleBtnEl" data-ref="middleBtnEl" class="{baseCls}-month" role="heading">{%this.renderMonthBtn(values, out)%}</div>',
        '<div id="{id}-nextEl" data-ref="nextEl" class="{baseCls}-next {baseCls}-arrow" role="presentation" title="{nextText}"></div>',
        '</div>',
        '<table role="grid" id="{id}-eventEl" data-ref="eventEl" class="{baseCls}-inner" cellspacing="0" tabindex="0">',
        '<thead>',
        '<tr role="row">',
        '<tpl for="dayNames">',
        '<th role="columnheader" class="{parent.baseCls}-column-header" aria-label="{.}">',
        '<div role="presentation" class="{parent.baseCls}-column-header-inner">{.:this.firstInitial}</div>',
        '</th>',
        '</tpl>',
        '</tr>',
        '</thead>',
        '<tbody>',
        '<tr role="row">',
        '<tpl for="days">',
        '{#:this.isEndOfWeek}',
        '<td role="gridcell">',
        '<div hidefocus="on" class="{parent.baseCls}-date"></div>',
        '</td>',
        '</tpl>',
        '</tr>',
        '</tbody>',
        '</table>',
        '<tpl if="showToday">',
        '<div id="{id}-footerEl" data-ref="footerEl" role="presentation" class="{baseCls}-footer">{%this.renderCloseBtn(values, out)%}</div>',
        '</tpl>',
        // These elements are used with Assistive Technologies such as screen readers
        '<div id="{id}-todayText" class="' + Ext.baseCSSPrefix + 'hidden-clip">{todayText}.</div>',
        '<div id="{id}-ariaMinText" class="' + Ext.baseCSSPrefix + 'hidden-clip">{ariaMinText}.</div>',
        '<div id="{id}-ariaMaxText" class="' + Ext.baseCSSPrefix + 'hidden-clip">{ariaMaxText}.</div>',
        '<div id="{id}-ariaDisabledDaysText" class="' + Ext.baseCSSPrefix + 'hidden-clip">{ariaDisabledDaysText}.</div>',
        '<div id="{id}-ariaDisabledDatesText" class="' + Ext.baseCSSPrefix + 'hidden-clip">{ariaDisabledDatesText}.</div>',
        '</div>',
        {
            firstInitial: function(value) {
                return Ext.picker.Date.prototype.getDayInitial(value);
            },
            
            isEndOfWeek: function(value) {
                // convert from 1 based index to 0 based
                // by decrementing value once.
                value--;
                var end = value % 7 === 0 && value !== 0;
                return end ? '</tr><tr role="row">' : '';
            },
            
            renderTodayBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.todayBtn.getRenderTree(), out);
            },
            
            renderMonthBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.monthBtn.getRenderTree(), out);
            },
            
            renderCloseBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.closeBtn.getRenderTree(), out);
            },

            renderTimePickerBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.timePicker.getRenderTree(), out);
            },

            renderTimeLabel: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.timeLabel.getRenderTree(), out);
            }
        }
    ],
    listeners: {
        hide: 'closeHandler'
    },
    beforeRender: function() {
        var me = this, _$Number = Ext.form.field.Number, today = Ext.Date.format(new Date(), me.format);
        
        me.closeBtn = new Ext.button.Button({
            ui: me.footerButtonUI,
            ownerCt: me,
            ownerLayout: me.getComponentLayout(),
            text: me.closeText,
            tooltipType: 'title',
            tabIndex: -1,
            ariaRole: 'presentation',
            handler: me.closeHandler,
            scope: me
        });

        me.timeLabel = Ext.create('Ext.form.Label', {
            text: me.timeText,
            cls: 'shr-time-field-Label'
        });

        me.timePicker = Ext.create('Shr.WebControls.TimeField', {
            id: this.id + '-time',
            ownerCt: me,
            ownerLayout: me.getComponentLayout(),
            format: me.timeFormat,
            altFormats: me.altTimeFormats,
            width: me.timeWidth,
            increment: 5,
            style: {
                padding: '0px 5px'
            }
        });
        
        me.callParent();
    },
    getRefItems: function() {
        var results = [],
            monthBtn = this.monthBtn,
            todayBtn = this.todayBtn,
            closeBtn = this.closeBtn,
            timePicker = this.timePicker;
            timeLabel = this.timeLabel;
        
        if (monthBtn) {
            results.push(monthBtn);
        }
        
        if (todayBtn) {
            results.push(todayBtn);
        }
        if (closeBtn) {
            results.push(closeBtn);
        }
        if (timePicker){
            results.push(timePicker);
        }
        if (timeLabel){
            results.push(timeLabel);
        }
        return results;
    },
    privates : {
        finishRenderChildren: function() {
            var me = this;
            me.callParent();
            me.closeBtn.finishRender();
            me.timePicker.finishRender();
            me.timeLabel.finishRender();
        }
    },
    
    closeHandler: function() {
        var me = this,
            btn = me.closeBtn,
            dateVal = me.getValue(),
            timeVal = me.timePicker.getValue(),
            merged = me.mergeValues(dateVal,timeVal);
        
        if (btn && !btn.disabled) {
            //Convert date value to integer to check if they're equal to avoid double posts
            if (!me.datesEqual(dateVal,merged)) {
                me.setValue(merged);
                me.fireEvent('select', me, me.value);
                me.onSelect();
            }            
        }
        me.hide();
         
        return me;
    },

     /**
     * Sets the current value to today.
     * @return {Ext.picker.Date} this
     */
    selectToday: function() {
        var me = this, btn = me.todayBtn, handler = me.handler;
        if (btn && !btn.disabled) {
            var date = new Date();
            me.setValue(date, true);
            me.timePicker.setValue(date);
            me.fireEvent('select', me, me.value);
            me.onSelect();
        }
        return me;
    },
        
    selectedUpdate: function(date) {
        this.callParent([Ext.Date.clearTime(date, true)]);
    },
    
    update: function(date, forceRefresh) {
        var me = this;
        me.timePicker.setValue(date);
        return this.callParent(arguments);
    },
    
    setValue: function(date, isFixed) {
        var me = this;

        me.value = date;
        me.update(me.value);
        return me;
    },

    // @private
    // @inheritdoc
    beforeDestroy: function() {
        var me = this;
        
        if(me.rendered) {
            Ext.destroy(
                me.timePicker,
                me.closeBtn
            );
        }
        
        me.callParent();
    },
    mergeValues: function (dateValue, timeValue) {
        var year = dateValue.getFullYear(),
            month = dateValue.getMonth(),
            day = dateValue.getDate(),
            hours = timeValue.getHours(),
            minutes = timeValue.getMinutes();

        return new Date(year, month, day, hours, minutes, 0, 0);

    },
    datesEqual: function (date1, date2){
        return date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth() && date1.getDate() == date2.getDate() &&
               date1.getHours() == date2.getHours() && date1.getMinutes() == date2.getMinutes();
    },
    handleDateClick: function(e, t) {
        var me = this,
            handler = me.handler,
            dateVal = new Date(t.dateValue),
            timeValue = me.timePicker.value;
        e.stopEvent();
        if(!me.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(me.disabledCellCls)){
            me.doCancelFocus = me.focusOnSelect === false;
            var merged = me.mergeValues(dateVal, timeValue);
            me.setValue(merged);
            delete me.doCancelFocus;
            
        //by pass on select to keep the window open
        me.fireEvent('select', me, me.value);
        if (handler) {
          handler.call(me.scope || me, me, me.value);
        }
        // event handling is turned off on hide
        // when we are using the picker in a field
        // therefore onSelect comes AFTER the select
        // event.
        me.onSelect();
    }
  }
});

///////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('Shr.WebControls.DateTimeField', {
    extend: 'Ext.form.field.Date',
    alias: 'widget.sysdatetimefield',
    requires: ['Ext.picker.DateTime'],
    msgTarget: 'side',
    dateFormat: Shr.DATE_FORMAT,
    altDateFormats: Shr.ALT_DATE_FORMATS,
    timeFormat: Shr.TIME_FORMAT,
    altTimeFormats: Shr.ALT_TIME_FORMATS,
    todayText: Shr.LABEL_Now,
    closeText: Shr.LABEL_Close,
    timeText: Shr.LABEL_Time,
    timeWidth: Shr.Time_Label_Width,
    invalidText: Shr.LABEL_InvalidText,
    formatText: '',
    fromPicker: false,
    initComponent: function () {
        // Necessary to ensure the base date field class uses the alternate
        // date format specified for the control. Done by copying the value,
        // rather than having the altFormats defined as a class property so
        // it can be changed with a single property set, rather than two.
        this.altFormats = this.altDateFormats;

        this.callParent(arguments);

        Ext.apply(this, {
            //startDay: 1, // this starts at Monday. The default is 0 which is Sunday
            minDate: this.minValue,
            maxDate: this.maxValue,
            disabledDatesRE: this.ddMatch,
            disabledDatesText: this.disabledDatesText,
            disabledDays: this.disabledDays,
            disabledDaysText: this.disabledDaysText,
            format: this.isMidnight(this.getMaybeDate(this.value)) ? this.dateFormat : this.dateFormat + ' ' + this.timeFormat,
            timeFormat: this.timeFormat,
            dateFormat: this.dateFormat,
            minText: Ext.String.format(this.minText, this.formatDate(this.minValue)),
            maxText: Ext.String.format(this.maxText, this.formatDate(this.maxValue))
        });

        this.setTriggers({
            //default trigger for the dropdown
            picker: {
                handler: 'onTriggerClick',
                scope: 'this'
            },
            triggerClear: {
                cls: 'x-form-clear-trigger',
                handler: this.onTriggerClearClick,
                scope: 'this'
            }
        });

        /*this.on({
            validitychange: function (obj, isValid, eOpts) {
                if (!isValid)
                    this.showError();
                else 
                    this.hideError();
            }
        });

        this.on({
            errorchange: function (obj, error, eOpts) {
                this.verifyContainers();
                if (this.quickContainer != null) {
                    Ext.tip.QuickTipManager.register({
                    target: 'quickTipContainer_' + this.inputId,
                    text: error
                    });
                }
            }
        });*/

        this.errorBtn = new Ext.Button({
            iconCls: 'x-fa fa-exclamation-circle red-text',
            style: {
                background: 'transparent',
                border: 0
            },
        });
    },

    showError: function () {
        if(this.quickContainer != null){
            this.quickContainer.add(this.errorBtn);
        }
    },

    hideError: function () {
        if (this.quickContainer != null) {
            this.quickContainer.remove(this.errorBtn, false);
        }
        
    },

    verifyContainers: function () {
        //validate we dont have a required field error
        this.fieldWarningContainer = Ext.getCmp('quickTipContainer_' + this.inputId);
        if (this.fieldWarningContainer != null) {
            return;
        }
        else {
            this.quickContainer = Ext.create('Ext.container.Container', {
                id: 'quickTipContainer_' + this.inputId,
                width: 23,
                style: {
                    'float': 'right'
                },
                renderTo: this.el.up(xtype = '.x-form-element')
            });
        }
    },

    createPicker: function () {
        var me = this, format = Ext.String.format;

        return new Ext.picker.DateTime({
            pickerField: me,
            floating: true,
            preventRefocus: true,
            hidden: true,
            minDate: me.minValue,
            maxDate: me.maxValue,
            disabledDatesRE: me.disabledDatesRE,
            disabledDatesText: me.disabledDatesText,
            ariaDisabledDatesText: me.ariaDisabledDatesText,
            disabledDays: me.disabledDays,
            disabledDaysText: me.disabledDaysText,
            ariaDisabledDaysText: me.ariaDisabledDaysText,
            format: me.format,
            showToday: me.showToday,
            startDay: me.startDay,
            minText: format(me.minText, me.formatDate(me.minValue)),
            ariaMinText: format(me.ariaMinText, me.formatDate(me.minValue, me.ariaFormat)),
            maxText: format(me.maxText, me.formatDate(me.maxValue)),
            ariaMaxText: format(me.ariaMaxText, me.formatDate(me.maxValue, me.ariaFormat)),
            editable: true,
            todayText: me.todayText,
            closeText: me.closeText,
            timeText: me.timeText,
            timeFormat: me.timeFormat,
            altTimeFormats: me.altTimeFormats,
            timeWidth: me.timeWidth,

            listeners: {
                scope: me,
                select: me.onSelect
            },
            keyNavConfig: {
                esc: function () {
                    me.inputEl.focus();
                    me.collapse();
                }
            }
        });
    },

    isMidnight: function (datetime) {
        if (Ext.isDate(datetime) && datetime.getHours() == 0 && datetime.getMinutes() == 0)
            return true;
        return false;
    },

    // Verify against different formats
    getMaybeDate: function (value) {
        if (!value)
            return '';

        //there is an issue when the user enters a time with a small 'am', not sure
        // if this is just AM thing, but since this is a low-level object, i'm only
        // fixing the known issue SCR 49030
        var strDate = value.toString();
        if (strDate != null && strDate != undefined && strDate.length > 0) {
            strDate = strDate.toUpperCase();
            if (strDate.indexOf('AM') != -1) {
                value = strDate;
            }
        }

        if (Ext.isDate(value)) {
            return value;
        }

        var v = undefined;
        v = Ext.Date.parseDate(value, this.dateFormat);
        if (v == null) {
            v = Ext.Date.parseDate(value, this.dateFormat + ' ' + this.timeFormat);
        }
        if (Ext.isDate(v)) {
            return v;
        }
        else {
            v = false;
        }

        // Get all the valid Date formats if available
        if (!this.altDateFormatsArray) {
            this.altDateFormatsArray = this.altDateFormats.split('|');
        }

        // Get all the valid Time formats if available
        if (!this.altTimeFormatsArray) {
            this.altTimeFormatsArray = this.altTimeFormats.split('|');
        }

        // Verify the date time value against each combination of 
        // Date and Time formats and stop once a valid format is found.
        if (!v && this.altDateFormatsArray && this.altTimeFormatsArray) {
            for (var i = 0, lenDate = this.altDateFormatsArray.length; i < lenDate && !v; i++) {
                for (var j = 0, lenTime = this.altTimeFormatsArray.length; j < lenTime && !v; j++) {
                    combinedFormat = this.altDateFormatsArray[i] + ' ' + this.altTimeFormatsArray[j];
                    v = Ext.Date.parseDate(value, combinedFormat);
                }
            }
        }

        // Verify the date time value against the Date formats 
        // and stop once a valid format is found.
        if (!v && this.altDateFormatsArray) {
            for (var i = 0, len = this.altDateFormatsArray.length; i < len && !v; i++) {
                v = Ext.Date.parseDate(value, this.altDateFormatsArray[i]);
            }
        }

        // Verify the date time value against the Time formats 
        // and stop once a valid format is found.
        if (!v && this.altTimeFormatsArray) {
            for (var i = 0, len = this.altTimeFormatsArray.length; i < len && !v; i++) {
                v = Ext.Date.parseDate(value, this.altTimeFormatsArray[i]);
            }
        }

        return v;
    },

    checkTrigger: function () {
        if (this.rendered) {
            if (Ext.isEmpty(this.getValue())) {
                this.getTrigger('triggerClear').hide();
                this.clearInvalid();
            } else {
                this.getTrigger('triggerClear').show();
            }
        }
    },

    afterRender: function () {
        this.callParent(arguments);
        this.checkTrigger();
    },

    onExpand: function () {
        var value = this.getValue();
        if (Ext.isDate(value))
            this.picker.setValue(value, true);
        else
            this.picker.setValue(new Date(new Date().setHours(0,0,0)), false);
    },

    onTriggerClearClick: function () {
        // clear contents of datefield
        this.setValue();
        eval(this.onchange);
    },

    updateAndFire: function () {
        if (!this.getRawValue())
            return '';

        var value = this.getRawValue();
        if (value)
            this.setValue(value);
        if (this.isDirty())
            eval(this.onchange);
    },

    setValue: function (value) {
        if (value) {
            // Verify value against different Date/Time formats
            value = this.getMaybeDate(value);
            if (this.isMidnight(value)) {
                this.format = this.dateFormat;
                value = Ext.util.Format.date(value, this.dateFormat)
            }
            else {
                this.format = this.dateFormat + ' ' + this.timeFormat;
                value = Ext.util.Format.date(value, this.dateFormat + ' ' + this.timeFormat);
            }

        }
        // Call the "parent" method of the Ext.form.field.Date base class
        this.callParent(arguments);
    },
    listeners: {
        select: function (dateTimeField, date) {
            this.fromPicker = true;
            this.updateAndFire();
        },
        specialkey: function(field, e){
                // e.HOME, e.END, e.PAGE_UP, e.PAGE_DOWN,
                // e.TAB, e.ESC, arrow keys: e.LEFT, e.RIGHT, e.UP, e.DOWN
                if (e.getKey() == e.ENTER) {
                    field.fireEvent('select',this);
                }
        },
        change: function (field, newValue, oldValue, eOpts) {
            var trigger = field.triggers.triggerClear;
            if (newValue && trigger.hidden) {
                trigger.show();
            } else if (!newValue && !trigger.hidden) {
                trigger.hide();
            }
        },
        blur: function (field, event, eOpts) {
            //For unknown reasons (some sort of focus issue?) the OnBlur fires after the calendar is displayed and causes issues in Chrome
            //So we need to see where we are coming from.
            //This check does not effect FF or IE so we will not code from the browser version
            if (this.fromPicker == false)
                this.updateAndFire();
        }
    },
    onDestroy: function () {
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    }
});

///////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('Shr.WebControls.TimeField', {
    extend: 'Ext.form.field.Time',
    allowBlank: true,
    selectOnFocus: true,
    disabledCls: 'shr-disabled',
    formatText: '',

    initComponent: function () {
        Shr.WebControls.TimeField.superclass.initComponent.call(this);
    },

    listeners: {
    'render': function (timeField, options) {
        if (!timeField.disabled && timeField.inputEl != null) {
            if (timeField.onclientchange != null && timeField.onclientchange != '' && timeField.onclientchange != undefined) {
                timeField.inputEl.dom.onchange = null;
                timeField.on('select', Ext.bind(function () { eval(timeField.onclientchange); }, timeField), timeField);
            }
        }
        }
    }
});

////////////////// END DATE PICKER CONTROLS //////////////////

Ext.override(Ext.form.field.Text, {
    listeners: {
        'afterrender': function () {
            if (this.onClientAfterRender) {
                eval(this.onClientAfterRender);
            }
        }
    }
});

Ext.define('Shr.WebControls.TextAreaContainer', {
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.ShrTextAreaContainer',
    displayMultiLanguage: false,

    constructor: function (cfg) {
        cfg = cfg || {};
        Shr.WebControls.TextAreaContainer.superclass.constructor.call(this, cfg);
    },

    initComponent: function () {
        Shr.WebControls.TextAreaContainer.superclass.initComponent.call(this);
        var me = this;
        this.layout = 'hbox';

        this.textArea = Ext.create('Shr.WebControls.TextAreaField', me.config.configTextArea);
        this.textArea.msgTarget = 'side';
        this.textArea.displayMultiLanguage = this.displayMultiLanguage;
        /*this.textArea.on({
            validitychange: function (obj, isValid, eOpts) {
                if (!isValid) {
                    me.showError();
                } else {
                    me.hideError();
                }
            }
        });
        */
        this.errorBtn = new Ext.Button({
            iconCls: 'x-fa fa-exclamation-circle red-text',
            style: {
                background: 'transparent',
                border: 0
            }
        });

        Ext.QuickTips.init();
        this.quickContainer = Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + me.textArea.inputId,
            height: 23,
            width: 23
        });

        var cont = Ext.create('Ext.container.Container', {
            layout: 'fit',
            items: [this.textArea]
        });
        this.items = [cont];

        if (this.displayMultiLanguage) {
           //Add multilanguage button
            this.multiLangBtn = Ext.create('Ext.button.Button', {
                id: me.id + '_btn',
                ui: 'multilanguage',
                iconCls: 'fa fa-pencil',
                style: {
                    background: 'transparent',
                    border: 0
                },
                listeners: {
                    click: function () {
                        me.win.show();
                    }
                }
            });
            this.items.push(this.multiLangBtn);

            this.store = new Ext.data.JsonStore({
                proxy: {
                    type: 'ajax',
                    pageParam: false, //to remove param "page"
                    startParam: false, //to remove param "start"
                    limitParam: false, //to remove param "limit"
                    url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'records',
                        totalProperty: 'totalCount'
                    },
                    extraParams: {
                        svcprovider: 'JsGetMultiLanguageText',
                        tablerowguid: me.tableRowGuid,
                        tablename: me.tableName,
                        columnname: me.columnName,
                        draftid: me.draftId,
                        sectionid: me.sectionId,
                        fieldid: me.fieldId,
                        isRequired: me.isRequired
                    }
                },
                rootProperty: 'records',
                autoLoad: true,
                autoDestroy: true,
                fields: [
					{ name: 'guid' },
					{ name: 'tableName' },
					{ name: 'columnName' },
					{ name: 'tableRowGuid' },
					{ name: 'languageCode' },
					{ name: 'isRequired' },
					{ name: 'fieldId' },
					{ name: 'sectionId' },
					{ name: 'languageDescription' },
					{ name: 'valueData' },
					{ name: 'isUserLanguage'}]
            });

            this.grid = new Ext.grid.Panel({
                store: this.store,
                autoScroll: true,
                frame: true,
                clicksToEdit: 1,
                selType: 'cellmodel',
                plugins: new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 1
                }),
                columns: [{
                    //id: 'guid',
                    header: 'guid',
                    dataIndex: 'guid',
                    hidden: true
                }, {
                    header: 'tableName',
                    dataIndex: 'tableName',
                    hidden: true
                }, {
                    header: 'columnName',
                    dataIndex: 'columnName',
                    hidden: true
                }, {
                    header: 'tableRowGuid',
                    dataIndex: 'tableRowGuid',
                    hidden: true
                }, {
                    header: 'languageCode',
                    dataIndex: 'languageCode',
                    hidden: true
                }, {
                    header: 'isRequired',
                    dataIndex: 'isRequired',
                    hidden: true
                }, {
                    header: 'fieldId',
                    dataIndex: 'fieldId',
                    hidden: true
                }, {
                    header: 'sectionId',
                    dataIndex: 'sectionId',
                    hidden: true
                }, {
                    header: Shr.LABEL_Language,
                    dataIndex: 'languageDescription',
                    width: 250
                }, {
                    header: Shr.LABEL_Value,
                    dataIndex: 'valueData',
                    width: 400,
                    editor: new Ext.form.TextField({
                        allowBlank: true
                    })
                }]
            }),

			this.win = new Ext.Window({
			    layout: 'fit',
			    closeAction: 'hide',
			    closable: false,
			    modal: true,
			    width: 665,
			    height: 250,
			    title: me.config.labels.dialogtitle,
			    items: [this.grid],
			    buttons: [{
			        text: me.config.labels.save,
			        handler: function () {
			            //serialize the records
			            var recordData = [];
			            me.store.each(function (record) {
			                if (record.dirty)
			                    recordData.push(record.data);
			            });

			            Ext.Ajax.request({
			                loadMask: true,
			                url: 'API/JsonFetcher.svc/Invoke',
			                params: {
			                    svcProvider: 'JsUpdateTaskDraftMultiLanguage',
			                    draftId: me.draftId,
			                    records: Ext.util.JSON.encode(recordData)
			                },
			                success: function (resp, options) {
			                    me.store.each(function (record) {
			                        if (record.data.isUserLanguage && me.textArea != null) {
			                            me.textArea.setValue(record.data.valueData);
			                        }
			                    });
			                    me.win.hide();
			                }
			            });
			        }
			    }, {
			        text: me.config.labels.cancel,
			        handler: function () {
			            me.win.hide();
			        }
			    }]
			});
        }
        else {
            //Set container layout to card to show the spell check button 
            //when displayMultiLanguage is false
            this.layout = 'card';
        }
        
        this.items.push(this.quickContainer);

        this.callParent(arguments);
    },
    showError: function () {
        this.quickContainer.add(this.errorBtn);
    },
    hideError: function () {
        this.quickContainer.remove(this.errorBtn, false);
    },
    showMultilanguagePopup: function () {
        var me = this;
        if (me.textArea.readOnly) {
            if (me.el.component.win) {
                me.el.component.win.show();
            }
        }
    },
    listeners: {
        click: {
            element: 'el', //bind to the underlying el property on the panel
            fn: function (ct) {
                this.el.component.showMultilanguagePopup();
            }
        },
        dblclick: {
            element: 'body', //bind to the underlying body property on the panel
            fn: function () { console.log('dblclick body'); }
        }
    }
});

Ext.define('Shr.WebControls.TextAreaField', {
    extend: 'Ext.form.field.TextArea',
    alias: 'widget.ShrTextAreaField',
    hideTrigger: false,
    autoSize: Ext.emptyFn,
    monitorTab: true,
    deferHeight: true,
    disabledCls: 'shr-disabled',
    width: 600,


    constructor: function (cfg) {
        cfg = cfg || {};
        Shr.WebControls.TextAreaField.superclass.constructor.call(this, cfg);
    },
    
    initComponent: function () {
        if (this.enabled && !this.multiLanguage) {
            this.disabled = false;
            this.enable();
        }

        Ext.QuickTips.init();
        this.callParent();
    },

    getId: function () {
        if (this.id == null && this.elId != null)
            this.id = this.elId;
        return this.callParent(arguments);
    },

    onChange: function (field, newValue, oldValue) {
        this.autoSize();
    },

    adjustSize: Ext.Component.prototype.adjustSize,

    getResizeEl: function () {
        return this.wrap;
    },

    getPositionEl: function () {
        return this.wrap;
    },

    // private
    alignErrorIcon: function () {
        this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
    },

    listeners: {
        'render': function (ct, position) {
//            // Change if there is an 'onchange' event attached to the textbox so that it will
//            // be fired by the Ext DateField either when the value is changed or when the user
//            // picks a value from the popup calendar. Also, clears the textbox onchange event,
//            // as it's now redundant, and would just get in the way of the other events.
//            if (this.el != null) {
//                var tbChange = this.el.dom.onchange;
//                if (tbChange != null) {
//                    this.el.dom.onchange = null;
//                    this.on('change', tbChange);
//                }
//            }

            if (!this.displayMultiLanguage) {
                this.wrap = this.el.wrap({ cls: "x-form-field-wrap" });

                // Temporary fix for Query Builder since it doesn't have all the new theme
                if (this.id.indexOf("QueryBuilder") > -1)
                {
                    this.trigger = this.wrap.createChild(this.triggerConfig ||
                        { tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger x-form-spell-trigger " });
                }
                else {
                    this.trigger = this.wrap.createChild(this.triggerConfig ||
                    {
                        tag: "span",
                        html: '<i class="fa fa-check fa-lg fa-stack-1x"></i><i class="fa fa-stack-1x abc">abc</i>',
                        cls: "fa-stack spellcheck-btn"
                    });
                }
            
                if (this.hideTrigger) {
                    this.trigger.setDisplayed(false);
                }
                this.initTrigger();
//              if (!this.width) {
//                  this.wrap.setWidth(this.el.getWidth() + this.trigger.getWidth());
//              }
                //Wrapping extra width for Spell check button.
                var containerObj = Ext.get(this.inputId.replace('_fieldText', ''))
                containerObj.setWidth(containerObj.getWidth() + 50)
            }

        },
        blur: function () {
            //we do not want this event for the multi-language version of this control
            //because it causes issues when the user edits the control via the popup
            if (!this.displayMultiLanguage) {
                eval(this.onchange);
            }
        }
    },

    initTrigger: function () {
        this.trigger.on("click", this.onTriggerClick, this, { preventDefault: true });
        this.trigger.addClsOnOver('x-form-trigger-over');
        this.trigger.addClsOnClick('x-form-trigger-click');
    },

    onDestroy: function () {
        if (this.wrap) {
            this.wrap.remove();
        }
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    },

    onDisable: function () {
        this.callParent(arguments);
        if (this.wrap) {
            this.wrap.addCls('x-item-disabled');
        }
    },

    onEnable: function () {
        this.callParent(arguments);
        if (this.wrap) {
            this.wrap.removeCls('x-item-disabled');
        }
    },

    onShow: function () {
        if (this.wrap) {
            this.wrap.dom.style.display = '';
            this.wrap.dom.style.visibility = 'visible';
        }
    },

    onHide: function () {
        this.wrap.dom.style.display = 'none';
    },

    onTriggerClick: function () {
        if (this.spell == null) {
            var spellCheckName = this.inputId.replace('_fieldText', '_SpellChecker');
            this.spell = GetRadSpell(spellCheckName);
            if (this.spell) {
                this.spell.SetTextSource(new HtmlElementTextSource(this.inputEl.dom));
            }
        }

        if (this.spell != null && Ext.isIE7) {
            var me = this;
            var oldValue = this.getValue();
            this.spell.OnClientDialogClosing = function () {
                if (oldValue != me.getValue())
                    me.fireEvent('change');
                Ext.WindowMgr.each(function (win) {
                    win.show();
                    win.resumeEvents();
                });
            };
        }

        if (this.spell != null && !Ext.isIE7) {
            var me = this;
            var oldValue = this.getValue();
            this.spell.OnClientDialogClosing = function () {
                if (oldValue != me.getValue())
                    me.fireEvent('change');
            }
        }

        if (this.spell != null) {
            this.spell.StartSpellCheck();
            if (Ext.isIE7) {
                var spellCheckWnd = Ext.getBody().child('.RadETableWrapper');
                document.body.appendChild(spellCheckWnd.dom);
            }
        }
    }
});


Ext.define('Shr.WebControls.SearchField', {
    extend: 'Ext.form.field.Text',
    alias: 'widget.searchfield',
    paramName: 'query',
    disabledCls: 'shr-disabled',
    enableKeyEvents: true,
    regex: /^[^<]*$/, //NO < IN THE SEARCH FIELD
    regexText: 'Special characters not allowed.',
    msgTarget: 'side',
    initComponent: function () {
        Ext.QuickTips.init();

        this.value = this.initialValue;

        this.callParent(arguments);

        this.setTriggers({
            triggerClear: {
                cls: 'x-form-clear-trigger',
                handler: function () { if (this.getValue() == null || this.getValue() == '' || this.disabled) return; this.setValue(''); this.fireEvent('search', this); },
                scope: 'this',
                hidden: true
            },
            triggerSearch: {
                cls: 'x-form-search-trigger',
                handler: function () { if (this.disabled || this.isValid() == false) return; this.fireEvent('search', this); },
                scope: 'this'
            }
        });

        this.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.onTrigger2Click();
            }
            if (e.getKey() == e.TAB) {
                this.onTrigger2Click();
            }

        }, this);

        this.on('keyup', this.checkTrigger, this);

    },

    checkTrigger: function () {
        if (this.rendered) {
            if (Ext.isEmpty(this.getValue())) {
                this.getTrigger('triggerClear').hide();
                this.clearInvalid();
            } else {
                this.getTrigger('triggerClear').show();
            }
        }
    },

    onTrigger1Click: function () {
        this.setValue('');
        setTimeout(Ext.bind(this.doPendingSearch, this), 150);
    },

    onTrigger2Click: function () {
        var v = this.getRawValue();
        if (v.length < 1) {
            this.onTrigger1Click();
            return;
        }

        this.checkTrigger();

        if (this.isValid()) {
            setTimeout(Ext.bind(this.doPendingSearch, this), 150);
        }
    },


    afterRender: function () {
        this.callParent(arguments);
        this.checkTrigger();
    },

    onDestroy: function () {
        this.un('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.onTrigger2Click();
            }
        }, this);

        this.un('keyup', this.checkTrigger);

        this.un('blur', function () {
            if (this.startValue != this.getValue() && this.getValue() != this.lastQuery && this.isValid()) {
                this.getTrigger('triggerClear').show();
                setTimeout(Ext.bind(this.doPendingSearch, this), 150);
            }
        }, this);

        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    },

    doPendingSearch: function () {
        this.lastQuery = this.getValue();
        this.fireEvent('search', this);
    },

    setValue: function (value) {
        this.callParent(arguments);

        if (this.inputEl != null) {
            this.inputEl.dom.value = value;
        }
        this.checkTrigger();
    },

    getId: function () {
        if (this.id == null && this.el != null && this.el.dom.id != null)
            this.id = this.el.dom.id;

        return this.callParent(arguments);
    },

    listeners: {
        'render': function (searchField, options) {
            if (searchField.inputEl != null) {
                if (searchField.initialDisplay != null) {
                    searchField.inputEl.dom.value = searchField.initialDisplay;
                }
            }

            // If the searchField is NOT disabled, then set various actions that will occur when
            // the value changes or when a selection is made. This is irrelevant when disabled.
            if (!searchField.disabled && searchField.el != null) {
                if (searchField.onclientchange != null && searchField.onclientchange != '') {
                    searchField.el.dom.onchange = null;
                    searchField.on('search', Ext.bind(function () { eval(searchField.onclientchange); }, searchField), searchField);
                }
            }
        }
    }
});


Ext.define('Shr.WebControls.ColorField', {
    extend: 'Ext.form.field.Picker',
    xtype: 'colorfield',
    editable: false,  // we do not want the use to type in the text box

    //we need to add the clear trigger
    config: {
        triggers: {
            clear: {
                cls: 'x-form-clear-trigger',
                handler: function () { this.setValue(); }
            }
        }
    },

    onTriggerClick: function (e) {
        if (this.disabled) {
            return;
        }
        if (this.colorList == null) {
            this.colorList = [];
            for (var i = 0; i < Shr.NAMED_COLORS.length; i++) {
                this.colorList[i] = Shr.NAMED_COLORS[i].value;
            }
        }

        this.menu = new Ext.menu.ColorPicker({
            shadow: true,
            autoShow: true,
            colors: this.colorList
        });
        this.menu.alignTo(this.inputEl, 'tl-bl?');

        this.menu.on(Ext.apply({}, this.menuListeners, {
            scope: this
        }));

        this.menu.show(this.inputEl);
    },

    setColor: function (color,selected) {
        if (color == '' || color == undefined) {
            if (this.emptyText != '')
                color = this.emptyText;
            else
                color = 'transparent';
        }
        if (selected) {
            Shr.WebControls.ColorField.superclass.setFieldStyle.call(this, {
                'background-color': '#' + color,
                'background-image': 'none'
            });
        }
        else {
            Shr.WebControls.ColorField.superclass.setFieldStyle.call(this, {
                'background-color': color,
                'background-image': 'none'
            });
        }
    },

    setValue: function (color,selected) {
        Shr.WebControls.ColorField.superclass.setValue.call(this, this.getColorName(color));
        this.setColor(color,selected);
    },

    menuListeners: {
        select: function (m, d) {
            this.setValue(d,true);
        },
        show: function () {
            this.onFocus();
        },
        hide: function () {
            this.focus();
            var ml = this.menuListeners;
            this.menu.un("select", ml.select, this);
            this.menu.un("show", ml.show, this);
            this.menu.un("hide", ml.hide, this);
        }
    },

    // private
    getColorName: function (value) {
        if (value != '') {
            for (var i = 0; i < Shr.NAMED_COLORS.length; i++) {
                if (Shr.NAMED_COLORS[i].value == value)
                    return Shr.NAMED_COLORS[i].name;
            }
        }
        return value;
    }
});

Ext.define('Shr.WebControls.HtmlEditorContainer', {
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.ShrHtmlEditorContainer',
    multiLanguage: false,
    constructor: function (cfg) {
        cfg = cfg || {};
        Shr.WebControls.HtmlEditorContainer.superclass.constructor.call(this, cfg);
    },
    initComponent: function () {
        Shr.WebControls.HtmlEditorContainer.superclass.initComponent.call(this);
		var me = this;
        this.layout = 'hbox';
        this.hideLabel = true;
		
        this.htmlEditor = Ext.create('Shr.WebControls.HtmlEditorField', me.config.configHtmlEditor);
        this.htmlEditor.msgTarget = 'side';
        /*this.htmlEditor.on({
            validitychange: function (obj, isValid, eOpts) {
                if (!isValid) {
                    me.showError();
                } else {
                    me.hideError();
                }
            }
        });*/

        this.errorBtn = new Ext.Button({
            iconCls: 'x-fa fa-exclamation-circle red-text',
            style: {
                background: 'transparent',
                border: 0
            }
        });
        
        Ext.QuickTips.init();
        this.quickContainer = Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + me.htmlEditor.id,
            height: 23,
            width: 23
        });

        this.items = [this.htmlEditor];

        if (this.multiLanguage) {
            //Add multilanguage button
            this.button = Ext.create('Ext.button.Button', {
                id: this.id + '_btn',
                ui: 'multilanguage',
                iconCls: 'fa fa-pencil',
                style: {
                    background: 'transparent',
                    border: 0
                },
                listeners: {
                    click: function () {
						this.up().win.height = 500;
                        this.up().win.show();
                    }
                }
            });
            this.items.push(this.button);

            this.store = new Ext.data.JsonStore({
                proxy: {
                    type: 'ajax',
                    pageParam: false, //to remove param "page"
                    startParam: false, //to remove param "start"
                    limitParam: false, //to remove param "limit"
                    url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'records',
                        totalProperty: 'totalCount'
                    },
                    extraParams: {
                        svcprovider: 'JsGetMultiLanguageText',
                        tablerowguid: me.tableRowGuid,
                        tablename: me.tableName,
                        columnname: me.columnName,
                        draftid: me.draftId,
                        sectionid: me.sectionId,
                        fieldid: me.fieldId,
                        isRequired: me.isRequired
                    }
                },
                rootProperty: 'records',
                autoLoad: true,
                autoDestroy: true,
                fields: [
					{ name: 'guid' },
					{ name: 'tableName' },
					{ name: 'columnName' },
					{ name: 'tableRowGuid' },
					{ name: 'languageCode' },
					{ name: 'isRequired' },
					{ name: 'fieldId' },
					{ name: 'sectionId' },
					{ name: 'languageDescription' },
					{ name: 'valueData' },
					{ name: 'isUserLanguage'}]
            });

            this.grid = new Ext.grid.Panel({
                store: this.store,
                selType: 'cellmodel',
				autoExpandColumn: 'valueData',
				cls:'HtmlText',    //This class is used to override the EXT css of not showing bullets/numbers
				columnLines: true,
                plugins: [Ext.create('Ext.grid.plugin.RowEditing', { clicksToEdit: 1 })],
                columns: [{
                    header: 'guid',
                    dataIndex: 'guid',
                    hidden: true
                }, {
                    header: 'tableName',
                    dataIndex: 'tableName',
                    hidden: true
                }, {
                    header: 'columnName',
                    dataIndex: 'columnName',
                    hidden: true
                }, {
                    header: 'tableRowGuid',
                    dataIndex: 'tableRowGuid',
                    hidden: true
                }, {
                    header: 'languageCode',
                    dataIndex: 'languageCode',
                    hidden: true
                }, {
                    header: 'isRequired',
                    dataIndex: 'isRequired',
                    hidden: true
                }, {
                    header: 'fieldId',
                    dataIndex: 'fieldId',
                    hidden: true
                }, {
                    header: 'sectionId',
                    dataIndex: 'sectionId',
                    hidden: true
                }, {
                    header: Shr.LABEL_Language,
                    dataIndex: 'languageDescription',
                    width: 200
                }, {
                    header: Shr.LABEL_Value,
                    dataIndex: 'valueData',
					flex: 1,
                    editor: Ext.create('Shr.WebControls.HtmlEditorField', { enabled: true, height: 200 })
                }]
            });

			this.win = new Ext.Window({
			    layout: 'fit',
			    closeAction: 'hide',
			    closable: false,
				autoScroll: true,
			    modal: true,
				fixed: true,
                floating: true,
				// Since HtmlEditor takes up a lot of space, we're making the height and 
                // width as big as we can based upon the screen resolution to make it easier
                // to work with.
			    width: Ext.Element.getViewportWidth() - 75,
			    height: Ext.Element.getViewportHeight() - 75,
			    title: me.config.labels.dialogtitle,
			    items: [this.grid],
			    buttons: [{
			        text: me.config.labels.save,
			        handler: function () {
						//update the records. in case the user just clicks the update button
                        // we want to preserve the value in the fields
                        //grid.stopEditing(false);
						
			            //serialize the records
			            var recordData = [];
			            me.store.each(function (record) {
			                if (record.dirty)
			                    recordData.push(record.data);
			            });

			            Ext.Ajax.request({
			                loadMask: true,
			                url: 'API/JsonFetcher.svc/Invoke',
			                params: {
			                    svcProvider: 'JsUpdateTaskDraftMultiLanguage',
			                    draftId: me.draftId,
			                    records: Ext.util.JSON.encode(recordData)
			                },
			                success: function (resp, options) {
			                    me.store.each(function (record) {
			                        if (record.data.isUserLanguage && me.htmlEditor != null) {
			                            me.htmlEditor.setValue(record.data.valueData);
			                        }
			                    });
								me.win.hide();
			                }
			            });
			        }
			    }, {
			        text: me.config.labels.cancel,
			        handler: function () {
						//update the records. in case the user just clicks the update button
                        // we do not want to preserve the value in the fields
                        //grid.stopEditing(true);

						me.win.hide();
			        }
			    }]
			});
        }

        this.items.push(this.quickContainer);

        this.callParent(arguments);
    },
	showError: function () {
        this.quickContainer.add(this.errorBtn);
    },
    hideError: function () {
        this.quickContainer.remove(this.errorBtn, false);
    }
});

Ext.define('Shr.WebControls.HtmlEditorField', {
    extend: 'Ext.form.field.HtmlEditor',
    alias: 'widget.ShrHtmlEditorField',

    fontFamilies: new Array('Arial', 'Calibri', 'Courier New', 'Tahoma', 'Times New Roman', 'Verdana'),
    disabledCls: 'shr-disabled',
    disabled: true,
    value: null,
    doc: null,
    multiLanguage: false,

    constructor: function(cfg) {
        cfg = cfg || {};
        Shr.WebControls.HtmlEditorField.superclass.constructor.call(this, cfg);
    },
    initComponent: function() {
        if (this.enabled && !this.multiLanguage) {
            this.disabled = false;
            this.enable();
            //kdm01 begin  
            //kdm02   var onClientChangeField = Ext.get(this.elId + '_hdnOnClientChangeField');
            var onClientChangeField = Ext.get(this.id.replace('_htmlEditor', '_hdnOnClientChangeField')); //kdm02
            if (onClientChangeField != null) {
                this.on('sync', function() {    
                    eval(onClientChangeField.dom.value);
                }, this, { buffer: 500 });  
            }
            //kdm01 end
        }

        Ext.QuickTips.init();
        this.callParent();
    },

    //add the spellcheck control
    
    onRender: function (ct, position) {
        Shr.WebControls.HtmlEditorField.superclass.onRender.call(this, ct, position);
        var spellCheckControl;
        //We want to find the RadSpell control
        //We only need one of them so get the first one (if there are multiple ones)
        var allItems = document.getElementsByTagName("span"); //slow but effective                          
        for (var i=0, max=allItems.length; i < max; i++) {
                if (allItems[i].id.endsWith("_SpellChecker") )
                {
                    spellCheckControl = allItems[i].id;
                    break;
                }
        }
        //If we cannot find the object then do not show the icon
        //This would be the case if the user is using any language other than ENG
        var trySpell = GetRadSpell(spellCheckControl);
        if (trySpell != undefined) {
            this.toolbar.add('-', {
                overflowText: Shr.LABEL_SpellCheck,
                cls: 'x-btn-icon',
                iconCls: 'shr-btn-spell',
                scope: {
                    obj: this,
                    spellCheckControl: spellCheckControl
                },
                handler: function () {
                    // Access properties specified in the 'scope' parameter via 'this'
                    var obj = this.obj,
                    spellCheckControl = this.spellCheckControl;

                    var spell = GetRadSpell(spellCheckControl);
                    spell._source = null;
                    spell.SetTextSource(new HtmlElementTextSource(obj.inputEl.dom));
                    var me = obj;
                    var oldValue = obj.getValue();
                    spell.OnClientDialogClosing = function () {
                        if (oldValue != me.getValue())
                        me.fireEvent('change');
                    };
                    spell.StartSpellCheck();
                    //We need to find the RadSpell window and bring it forward
                    //This is necessary when we have a popup window for the editor because the control 
                    //lives in the main page and not the popup
                    var all = document.getElementsByTagName("table");  // go thru the tables
                    for (var i=0, max=all.length; i < max; i++) {
                            if (all[i].id.startsWith("RadWindowContentWrapper") )
                            {
                            document.getElementById(all[i].id).style.zIndex = "999999";
                            }
                    }
                },
                clickEvent: 'mousedown',
                tooltip: Ext.QuickTips && Ext.QuickTips.isEnabled() ? Shr.LABEL_SpellCheck : null,
                tabIndex: -1
            });
        }
    },

    getDoc: function() {
        return this.iframeEl.dom.contentDocument || (typeof this.getWin() != "undefined" ? this.getWin().document : null);
    },
	
    getId: function () {
        if (this.id == null && this.elId != null)
            this.id = this.elId + '_htmlEditor';

		return this.callParent(arguments);
    }
});


// Defining model here because they cannot be defined
// inline. This is because the model property of the 
// store only accepts a string, which is the name 
// of what we're defining here.
Ext.define('ShrWebControlsComboBoxFieldModel', {
    extend: 'Ext.data.Model',
    fields: [
                { name: 'Value' },
                { name: 'Name' }
            ]
});

Ext.define('Shr.WebControls.ComboBoxField', {
    extend: 'Ext.form.field.ComboBox',
    alias: 'widget.comboboxfield',

    valueField: 'Value',
    displayField: 'Name',
    selectOnTab: true,
    typeAndTab: false,
    typeAndTabValue: null,
    allowBlank: true,
    disabledCls: 'shr-disabled',
    listConfig: {
        loadingText: Shr.LABEL_Searching,
        cls: 'shr-toolbar-people-picker-list'
    },
    minChars: 0,
    typeAhead: false,
    forceSelection: false,
    selectOnFocus: true,
    grow: true,
    showClear: false,
    showSearch: false,
    multiSelectPicker: false,
    initialValue: null,
    initialDisplay: null,
    inputFieldAttributes: null,
    msgTarget: 'side',

    // Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
    // We set it to false so that it will be either larger or smaller then the combo width.
    // In the later event we will set it to the width of the combo in the expand event below
    matchFieldWidth: false, 

    // properties for a static combo box with defined data
    data: null,

    // properties for a combo box that uses an external store
    store: null,

    // properties for an AJAX CodesDao search
    dataType: null,
    showDash: false,
    codeFiltering: false,
    filter: null,
    preFilter: null,
    sortProperty: '',
    hideCodes: false,
    hideInactiveCodes: false,

    // properties for a search from an AJAX function call
    searchFunction: null,
    searchDraftId: null,
    searchSectionId: null,
    searchRecordId: null,
    searchFieldId: null,
    searchOtherParam: null,
    searchNoMatchReturnsNull: null,
    //Current Object selected
    shrValueObject: {},
    initComponent: function () {
        var ptr = this;
        // If the combobox is NOT disabled, then create the data store that the
        // control will use. This may be either a local store or a remote call.
        if (!this.disabled) {
            //default trigger for the dropdown
            var triggers = {
                picker: {
                    handler: 'onTriggerClick',
                    scope: 'this'
                }
            };

            if (this.showClear || this.multiSelectPicker) {
                triggers.triggerClear = {
                    cls: 'x-form-clear-trigger',
                    handler: function () {
                        if (this.getValue() == null || this.getValue() == '' || this.disabled)
                            return;
                        this.clearValue();
                        this.fireEvent('select', this);
                    },
                    scope: 'this'
                };
            }

            if (this.showSearch) {
                triggers.triggerSearch = {
                    cls: 'x-form-search-trigger',
                        handler: function () { if (this.disabled) return; this.fireEvent('search', this); },
                    scope: 'this'
                };
            }

            this.setTriggers(triggers);

            if (this.config.isCodeDescriptionModel) {
                this.queryMode = 'local';
                this.store = Ext.create('Ext.data.Store', {
                    fields: ['Code', 'Description'],
                    data: this.config.data
                });
                this.valueField = 'Code',
                this.displayField = 'Description'
            }
            else if (this.config.data != null) {
                this.queryMode = 'local';
                this.store = Ext.create('Ext.data.Store', {
                    model: 'ShrWebControlsComboBoxFieldModel',
                    data: this.config.data
                });
            } else if (this.searchFunction != null) {
                this.queryMode = 'remote'; // the default
                this.store = Ext.create('Ext.data.Store', {
                    model: 'ShrWebControlsComboBoxFieldModel',
                    proxy: {
                        type: 'ajax',
                        url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                        actionMethods: {
                            read: 'POST'
                        },
                        extraParams: {
                            'svcprovider': 'JsSearchByListProvider',
                            'listProvider': ptr.searchFunction,
                            'query': ptr.lastQuery == null ? '' : ptr.lastQuery,
                            'draftId': ptr.searchDraftId,
                            'sectionId': ptr.searchSectionId,
                            'recordId': ptr.searchRecordId,
                            'fieldId': ptr.searchFieldId,
                            'otherParam': ptr.searchOtherParam,
                            'includeDash': ptr.showDash
                        },
                        reader: {
                            type: 'json',
                            rootProperty: 'items'
                        }
                    }
                });
            } else if (this.dataType != null) {
                this.queryMode = 'remote'; // the default
                this.store = Ext.create('Ext.data.Store', {
                    model: 'ShrWebControlsComboBoxFieldModel',
                    proxy: {
                        type: 'ajax',
                        url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                        actionMethods: {
                            read: 'POST'
                        },
                        extraParams: {
                            'svcprovider': 'JsSearchByDataType',
                            'dataType': ptr.dataType,
                            'sortProperty': ptr.sortProperty == null ? '' : ptr.sortProperty,
                            'query': ptr.lastQuery == null ? '' : ptr.lastQuery,
                            'filter': ptr.filter == null ? '' : ptr.filter,
                            'codeFiltering': ptr.codeFiltering,
                            'currentValue': ptr.initialValue == null ? '' : ptr.initialValue,
                            'preFilterName': ptr.preFilter == null ? '' : ptr.preFilter,
                            'includeDash': ptr.showDash,
                            'hideCodes': ptr.hideCodes,
                            'hideInactive': ptr.hideInactiveCodes
                        },
                        reader: {
                            type: 'json',
                            rootProperty: 'items'
                        }
                    }
                });

            } else if (this.store != null)
            {
               //if we have a store then just load
            } 
            else {
                this.disabled = true;
            }
        }

        // Disable the combo if the textbox element was disabled or there's no data
        // so the user can't use the dropdown to select a different value.
        this.disabled = this.disabled || this.store == null;

        //the minimum width for the combobox's list should be the same as the component's width 
        this.defaultListConfig = {
            minWidth: this.width,
            maxHeight: 300,
            loadingHeight: 70,
            shadow: 'sides'
        };
        // Call the base ComboBox initialization.
        this.callParent(arguments);
    },
	
    //override base Ext functionality
    getId: function () {

        if (this.id == null && this.el != null && this.el.dom.id != null)
            this.id = this.el.dom.id;

        return this.callParent(arguments);
    },

    // Override behavior of the function that initializes the field value
    // so it doesn't retrieve the value from the bound textbox DOM element
    // as this contains the current description, not the value.
    initValue: function () {
        if (!Ext.isEmpty(this.initialValue)) {
            // Set the start value for the combo box field if there is an initial value
            // set. This value is a composite object with property values for the value
            // and display fields, which come from the element (TextBox) value with the
            // description and the initialValue property with the underlying value.
            var startValue = {};
            startValue[this.valueField] = this.initialValue;
            startValue[this.displayField] = this.initialDisplay;
            this.setValue(startValue);
            this.select(this.initialValue); // we need to select the value for local stores so when the user drops down the combo the proper item is selected
            
            var selModel = this.getPicker().getSelectionModel();
            selModel.lastSelected = this.initialValue;

            this.originalValue = this.getValue();
        } else {
            this.callParent(arguments);
        }
    },

    //Ext override
    //Description: Executes a query to filter the dropdown list. Fires the beforequery event prior to performing the query allowing the query action to be canceled if needed.
    doQuery: function (q, forceAll) {
        if (this.disabled)
            return;
        if (this.queryMode == 'local')
        {
            // by default local stores do NOT show the entire store selection when the typed value is not found
            // the code below forces it to act similar to how remote stores work
            this.store.clearFilter();
            this.store.filter(this.displayField, q); //set the filter for what the user typed in
            this.store.load(); // apply the filter
            var filteredStoreCount = this.store.getCount();
            this.store.clearFilter();
            this.store.load();
            if (filteredStoreCount == 0)
            {
                this.callParent(this, q, true); // we force all records to be displayed
            }
            else
            {
                this.callParent(arguments);   
            }
        }
        else  // remote
        {
            this.callParent(arguments);   
        }
    },

    //fires when the focus is removed from the field.
    beforeBlur: function () {
        //we need to see if the text that the user entered had a match or if it is empty
        //BUT only if it is a required field
        //if it did then we are okay and do nothing
        //if it did not then we need to set the value back to the previous value and then select it
        if (this.typeAndTab == null || !this.typeAndTab) {
            var record;
           
            //if the field can be empty and the user empties it then return
            if (this.showClear == true && this.getRawValue() == '')
            {
                this.setValue('');
                this.setRawValue('');
                //we purposely return here
                return;
            }


            //if there is no data in the store then return
            //this usually means that the dropdown has not been selected or the user has not typed anything which loads the store
            if (this.store.getCount() < 1)
            {
                //if there is an initial value then set it eventhough the store is empty
                if (this.initialValue != null && this.initialValue != undefined && this.initialValue != '' && this.initialValue.Value !== null)
                {
                    this.setValue(this.initialValue);
                    this.setRawValue(this.initialDisplay);
                }
                //we purposely return here
                return;
            }

            //we have a store with data so...
            var q = this.getRawValue();  //this is the current complete text (name and value)
            var val = Shr.WebControls.ComboBoxField.superclass.getValue.call(this); // this is the value of the current selection or typed in value

            //see if the value is in the list
            if (val != null)  //if the value is different then we know that val is just the value and not the complete description
            {
                record = this.findRecord(this.valueField, val); // smiple find
            }
            //if it is not then we reset the selection back to it's previous value
            if (record == false || record == undefined)
            {
                //before we set it back we need to reload the unfiltered store 
                //so the record will position properly
                this.store.clearFilter();

                this.store.load({
                    scope: this,
                    callback: function(records, operation, success) {
                        var selModel = this.getPicker().getSelectionModel();
                        var lastSelectedItem = selModel.getLastSelected(); // this is the value of the item

                        if (lastSelectedItem == null || lastSelectedItem.data == null)
                        {
                            lastSelectedItem = this.initialValue;  // if we have no selected item then use the initial value
                        }
                        else
                        {
                            lastSelectedItem = lastSelectedItem.data.Value
                        }
                        record = this.findRecord(this.valueField, lastSelectedItem);
                        if (record != false && record != undefined)
                        {
                            this.setValue(record.data[this.valueField]);
                            this.setRawValue(record.data[this.displayField]);
                        }
                    }
                });
            }

            if (record != false && record != undefined)
            { 
                this.setValue(record.data[this.valueField]);
                this.setRawValue(record.data[this.displayField]);
            }

            if (this.showClear == true && record == false)
            {
                this.setValue('');
                this.setRawValue('');
            }
        }
    },

    //fires only the first time the combo is loaded for remote data only however
    //but also fires when the user types in something
    //or when the store is becoming unfiltered
    onLoad: function () {
        this.ForceSelection = false;
        if (this.typeAndTab && this.store != null && this.store.getCount() == 1) { // for only beforeBlur event
            this.superClassOnLoadOverride();

            var r = this.store.getAt(0);
            this.setValue(r.data);
            this.setRawValue(r.data[this.displayField]);
            this.fireEvent('select', this);
        } else if (this.typeAndTab && this.store != null && this.store.getCount() > 0) { // for only beforeBlur event            
            this.superClassOnLoadOverride();
        } else if (this.store != null && this.store.getCount() == 0) {  //nothing was found
            if (this.lastQuery != null && this.lastQuery != '') {
                if (this.searchNoMatchReturnsNull != true) {
                    this.lastQuery = null;
                    this.el.focus();
                    if (this.queryMode == 'local')
                    {
                        this.store.filter(this.displayField, '');
                        this.el.focus();
                        this.expand();
                    } else {
                        this.store.load();
                    }
                } else {
                    this.setValue(this.lastQuery);
                }
            }

            this.ignoreValue = true;
        } else { // just load
            this.ignoreValue = (this.store == null || this.store.getCount() != 1);  // does not matter...
            this.superClassOnLoadOverride();
        }

        this.typeAndTab = false;
    },

    //private function used above
    superClassOnLoadOverride: function () {
        if (!this.hasFocus) {
            return;
        }
        if (this.store != null && this.store.getCount() > 0) {
            if (this.lastQuery == this.allQuery) // allQuery = ""
            {  
                if (this.editable) {
                    this.inputEl.dom.select();
                }
                //select the initial value and then expand
               if (this.initialValue != '[ Value=null  Name= ]') //local store empty value
               {
                    var beforeSelectValue = this.getValue();
                    this.select(this.initialValue);
                    var afterSelectValue = this.getValue();
                    /*
                       This happens when the value in the dropdown value field is not in the store
                       We add it to the store below so we can sync to it
                       This occurs when the list box has a filter (defaults to 1000 global constant) which
                       causes the value to not be in the list, but the user was able to 'find' an approperiate vale
                       outside of the list.
                       It appears that local stores do not limit their selection list so we do not need this code for them 
                    */
                    if (this.queryMode == 'remote')
                    {
                        //check the store because the record may be there, but the discription could have changed
                        //this can happen when the DisplayDescription (business dao property) is different then the 'standard' description
                        var record = this.store.findRecord(this.valueField, afterSelectValue[this.valueField]);
                        if (record == null)
                        {
                            var missingRecord = {};
                            missingRecord[this.valueField] = afterSelectValue[this.valueField];
                            missingRecord[this.displayField] = beforeSelectValue[this.displayField];
                            //this adds the record to the store so we can select it below
                            this.inputEl.dom.value = missingRecord[this.displayField];
                            this.store.insert(0, missingRecord);
                            this.select(this.initialValue);
                        }
                        this.expand();
                        this.setPickerWidth();
                    }
               }

            } else if (this.ignoreValue != true)
            {
                this.doAutoSelect();// selects first item
            }
            else {
                this.ignoreValue = null;
            }
        } else {
            this.onEmptyResults();
        }
    },
    //Workaround to set the width of the picker, the main issue was the records that did not fit in a single line
    //making the scroll offset, by letting the picker expand or contract as needed with width = 'auto'
    //we know if the picker is shorter or bigger than the field. 
    //If the picker is shorter the minWidth should be the same as the fields width and also we set the width as string in order to override the 'auto' immediately.
    //If the picker is longer we need to set the pickers width as it's own to let it run trough runLayout.
    setPickerWidth: function(){
        var picker = this.getPicker(),
            fieldWidth = this.bodyEl.getWidth();

        picker.setMinWidth(fieldWidth);
        picker.setWidth('auto');

        if (picker.getWidth() < fieldWidth) {
            picker.setWidth(fieldWidth + 'px');
        } else {
            picker.setWidth(picker.getWidth())
        }
    },
    //Override Ext setValue
    setValue: function (val) {
        var me = this;
        if (typeof (me.importer) == 'function') {
            val = me.importer.apply(me, [val]);
        }

        if (val != null && typeof (val) == 'object') {
            //Validate if comboboxfield is instantiated by Resource Editor, 
            if (val.ResourceType !== null) {
                Ext.form.ComboBox.superclass.setValue.call(me, val[me.displayField]);
                me.typeAndTab = true; //set true to avoid set an empty value in beforeBlur function.
            } else if (me.value != val.Code) {
                Ext.form.ComboBox.superclass.setValue.call(me, val[me.value]);
            }
            //Set current value to shrValueObject.            
            me.shrValueObject = val;
            me.isValueObject = true;
        } else {
            Shr.WebControls.ComboBoxField.superclass.setValue.call(me, val);
            me.isValueObject = false;
        }

        if (me.rendered && me.isValueObject) {
            // Ext somehow prevents us from using the Request object to get the text
            // that the user entered. So we'll save it in a hidden field that we've
            // created server-side with a specific name.
            var rawField = Ext.get(me.inputEl.id);
            if (rawField != null) {
                rawField.dom.value = me.getRawValue();
            }

            var valueField = Ext.get(me.inputEl.id.replace('_raw', '_value'));
            if (valueField != null && rawField.id != valueField.id) {
                if (val != null) // we do not want to send null so...
                    valueField.dom.value = me.isValueObject ? val[me.valueField] : val;
                else
                    valueField.dom.value = "";
            }
        }
    },

    getValue: function () {
        var val = this.exporter(this.callParent(arguments), this.getRawValue());
        if (this.isSameValue(val, this.startValue))
            return this.startValue; // For change detection
        return val;
    },

    //private function used by getValue() above
    exporter: function (value, display) {
        var ret = {};
        if (value != null && this.shrValueObject !== null && this.isValueObject) {
            ret[this.valueField] = this.shrValueObject[this.valueField];
            ret[this.displayField] = this.shrValueObject[this.displayField];;
        }
        else {
            ret[this.valueField] = value;
            ret[this.displayField] = display;
        }

        ret.toString = function () {
            var s = "[";
            for (var x in this) {
                var q = this[x]; if (typeof (q) == "function") continue;
                s = s + " " + x + "=" + this[x] + " ";
            }
            return s + "]";
        };

        return ret;
    },

    //private function used by getValue() above
    isSameValue: function (val1, val2) {
        if (typeof (val1) != typeof (val2))
            return false;
        if (val1 == null)
            return val2 == null;
        if (typeof (val1) != "object")
            return val1 == val2;

        for (var x in val1) {
            if (val1[x] != val2[x])
                return false;
        }
        for (var y in val2) {
            if (val1[y] != val2[y])
                return false;
        }

        return true;
    },

    //note that this is only fired on a postback
    onDestroy: function () {
        if (this.dqTask !== null && typeof (this.dqTask) != 'undefined') {
            this.dqTask.cancel();
        }
        if (this.taTask !== null && typeof (this.tsTask) != 'undefined') {
            this.taTask.cancel();
        }
        if (this.view) {
            this.view.el.removeAllListeners();
            this.view.el.remove();
            this.view.purgeListeners();
            this.view.destroy();
            this.view = null;
        }
        if (this.store) {
            var store = this.store;
            this.bindStore(null);
        }
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    },

    // Updates dataType client-side and if the value is different than
    // the existing value we'll trigger the store to load again.
    // Note: This is currently only used by QueryBuilder.js
    setDataType: function (newDataType) {
        var triggerLoad = (this.dataType != newDataType);
        this.dataType = newDataType;

        if (triggerLoad)
            this.store.load();
    },

    listeners: {
        // need to add code to the select event to populate values
        'select': function () {
            if (!this.disabled && this.inputEl != null) {
                var val = Shr.WebControls.ComboBoxField.superclass.getValue.call(this);
                var record = this.findRecord(this.valueField || this.displayField, val);
                var index = this.store.indexOf(record);
                if (this.store != null && this.store.getCount() > 0 && index >= 0) {
                    this.setValue(record.data[this.valueField]);
                    this.setRawValue(record.data[this.displayField]);
                    
                    // this is needed so that when the user has a filtered search (typing a value)
                    // we have the proper field set once the dropdown is re-selected
                    if (this.queryMode != 'local') this.initialValue = record.data[this.valueField]; 
                }
            }
        },
        'render': function (comboBox, options) {
            if (comboBox.inputEl != null) {
                if (comboBox.initialDisplay != null && comboBox.initialDisplay != '[ Value=null  Name= ]') {
                    comboBox.inputEl.dom.value = comboBox.initialDisplay;
                }
            }

            // If the combo is NOT disabled, then set various actions that will occur when
            // the value changes or when a selection is made. This is irrelevant when disabled.
            if (!comboBox.disabled && comboBox.inputEl != null) {
                if (comboBox.onclientchange != null && comboBox.onclientchange != '' && comboBox.onclientchange != undefined) {
                    comboBox.inputEl.dom.onchange = null;
                    comboBox.on('select', Ext.bind(function () { eval(comboBox.onclientchange); }, comboBox), comboBox);
                } else {

                    // Change if there is an 'onchange' event attached to the textbox. If there is
                    // then get the function reference and make it so this will be invoked in the
                    // combo box select event, which happens at more specific times, such as picking
                    // from the list. When this happens we clear the textbox onchange event, as it's
                    // now redundant, and would just get in the way of the other event.
                    if (comboBox.inputFieldAttributes != null && comboBox.inputFieldAttributes != '') {
                        var tbChange = comboBox.inputFieldAttributes.onchange;
                        if (tbChange != null && tbChange != '') {
                            comboBox.inputEl.dom.onchange = null;
                            comboBox.on('select', Ext.bind(function () { eval(tbChange); }, comboBox), comboBox);
                        }
                    }
                }

                if (comboBox.ondblclick != null && comboBox.ondblclick != '') {
                    comboBox.el.dom.ondblclick = null;
                    comboBox.el.on('dblclick', Ext.bind(function () { eval(comboBox.ondblclick); }, comboBox), comboBox);
                }
            }

            if (this.isCodeDescriptionModel) {
                this.triggers.picker.setVisible(true);
                if (typeof this.triggers.triggerSearch != 'undefined') this.triggers.triggerSearch.setVisible(this.showSearch);
                if (typeof this.triggers.triggerClear != 'undefined') this.triggers.triggerClear.setVisible(this.showClear);
            }
        }
    }
});


Ext.define('Shr.WebControls.PickerField', {
    extend: 'Ext.container.Container',
    layout: 'fit',
    cls: 'shr-field-picker x-form-field-wrap',
    pickerDialog: null,
    hasPicker: false,
    leftList: null,
    rightList: null,
    comboBox: null,
    valueEl: null,
    value: null,
    initialValue: null,
    initialDisplay: null,
    isOkCancel: true,
    selectOnTab: true,

    // general picker properties
    pickerControl: null,
    multiSelectPicker: false, // renamed from multiSelect because that is now a property on the Ext.form.field.ComboBox
    showClear: false,
    urlParams: null,
    isGenericPicker: false,

    // properties for an AJAX CodesDao search
    dataType: null,
    codeFiltering: false,
    filter: null,
    preFilter: null,

    // properties for a search from an AJAX function call
    searchFunction: null,
    searchDraftId: null,
    searchSectionId: null,
    searchRecordId: null,
    searchFieldId: null,
    searchOtherParam: null,

    showComboBox: true,

    initComponent: function () {
        this.callParent(arguments);

        this.hasPicker = this.pickerControl != null && this.pickerControl != '';
        if (this.hasPicker) {
            this.pickerDialog = Ext.create('Shr.WebControls.Dialog', {
                title: '',
                destroyOnClose: false,
                showImmediate: false,
                showOkCancel: this.isOkCancel,
                whiteBackground: false,
                sourceControl: this.pickerControl,
                el: Ext.get(this.renderTo)
            });
        }

        this.value = this.initialValue;
       
        if (this.multiSelectPicker)
        {
             this.selectedValues = new Ext.util.MixedCollection();
        }
       
       // Do no create combo if this is a generic picker		
		if (this.isGenericPicker === false && this.showComboBox == true) {
			// Creates combo box and passes along all properties specified
			// by this picker control to the combo.
			this.comboBox = Ext.create('Shr.WebControls.ComboBoxField', this.comboBoxProperties);

			// Manually apply property settings that can differ between
			// the picker control and the combo box.
			Ext.apply(this.comboBox, {
				showSearch: this.hasPicker && !this.multiSelectPicker,
				showClear: this.showClear || this.multiSelectPicker,
				width: (this.width != '' && this.width != null) ? this.width : 240,

				inputFieldAttributes: this.inputFieldAttributes
			});

			this.comboBox.on('select', this.onComboBoxSelected, this);

			//because of the way the picker control is made we need to create the triggers here
			//vs. ComboBox.cs or CodeSelect.cs
			this.comboBox.setTriggers({
				//default trigger for the dropdown
				picker: {
					handler: 'onTriggerClick',
					scope: 'this'
				},
				triggerClear: {
					cls: 'x-form-clear-trigger',
					handler: this.onClearMe,
					scope: 'this',
					hidden: !(this.showClear || this.multiSelectPicker) || this.disabled
				},
				triggerSearch: {
					cls: 'x-form-search-trigger',
					handler: function () { if (this.disabled) return; this.fireEvent('search', this); },
					scope: 'this',
					hidden: !(this.hasPicker && !this.multiSelectPicker) || this.disabled
				}
			});
			this.add(this.comboBox);
		}
	    
    },

    onClearMe: function () {
        if (this.getValue() == null || this.getValue() == '' || this.disabled)
            return;
        this.clearValue();
        this.fireEvent('select', this);
    },

    getValue: function () {
        if (this.multiSelectPicker) {
            return Ext.JSON.encode(this.selectedValues.items);
        } else if (this.comboBox != null) {
            return this.comboBox.getValue();
        }

        return null;
    },

    getValueKeys: function (delimiter) {
        if (this.multiSelectPicker) {
            var keyList = null;
            if (delimiter == null || delimiter == '')
                delimiter = ',';

            for (var i = 0; i < this.selectedValues.items.length; i++) {
                var selectedValue = this.selectedValues.items[i];
                if (keyList == null) {
                    keyList = selectedValue.key;
                } else {
                    keyList += delimiter + selectedValue.key;
                }
            }

            return keyList;
        } else if (this.comboBox != null) {
            var comboValue = this.comboBox.getValue();
            if (comboValue != null) {
                return comboValue[this.comboBox.valueField];
            }
        }

        return null;
    },

    getValueKeysArray: function () {
        var keyArray = [];
        if (this.multiSelectPicker) {
            Ext.each(this.selectedValues.items, function (selectedValue) {
                keyArray.push(selectedValue.key);
            });
        }
        else if (this.comboBox != null) {
            var comboValue = this.comboBox.getValue();
            if (comboValue != null && comboValue != '') {
                keyArray.push(comboValue[this.comboBox.valueField]);
            }
        }

        return keyArray;
    },

    getId: function () {
        if (this.id == null && this.elId != null)
            this.id = this.elId;

        return this.callParent(arguments);
    },

    setPickerDialogState: function (showingResults, title, width, height) {
        var ptr = this;
        var toolbar = this.pickerDialog.dialogWindow.getDockedItems(); //get the docked items
        var okButton = toolbar[1].getComponent(0); //get the OK button from the toolbar
        var myFunc;
        if (showingResults) {
            // Change how the dialog works so on clicking OK we won't do
            // a postback, and instead will select the current results.
            myFunc = function () { ptr.selectDialogResult(); };
            okButton.setHandler(myFunc);
        }
        else if (okButton.getText() !== ptr.pickerDialog.closeText) {
            myFunc = function () { ptr.pickerDialog.update('OK'); };
            okButton.setHandler(myFunc);
        }

        this.title = title;
        if (title != null)
            this.pickerDialog.setTitle(title);
        if (width != null)
            this.pickerDialog.setWidth(width);
        if (height != null)
            this.pickerDialog.setHeight(height);
    },

    // Should be associated with the event fired when the results grid for a picker
    // is created client-side to select the first result (in single-select mode) or
    // all results (in multi-select mode). If in single-select and there's only one
    // result, then this is automatically chosen and the picker closes.
    setDialogResultGrid: function (grid) {
        this.resultGrid = grid;
        if (!this.multiSelectPicker) {
            if (grid.getRows().length > 0) {
                grid.setCurrentRow(grid.getRows()[0]);
            }

            var ptr = this;
            if (grid.getRows().length == 1) {
                setTimeout(function () { ptr.selectDialogResult(); }, 250);
            }
        }
        else {
            grid.selectAll();
        }
    },

    selectDialogResult: function () {
        if (this.resultGrid == null) return;

        if (!this.multiSelectPicker) {
            var selectedRow = this.resultGrid.getCurrentRow();
            if (selectedRow != null) {
                if (this.comboBox != null) {
                    var data = {};
                    data[this.comboBox.valueField] = selectedRow.key;
                    data[this.comboBox.displayField] = selectedRow.text;

                    this.comboBox.setValue(data[this.comboBox.valueField]);
                    this.comboBox.setRawValue(data[this.comboBox.displayField]);
                    this.comboBox.initialValue = data[this.comboBox.valueField];
                    this.comboBox.initialDisplay = data[this.comboBox.displayField];
                    this.comboBox.fireEvent('select', this.comboBox);
                }
                var data = { key: selectedRow.key, text: selectedRow.text };
                if(this.isGenericPicker === false)
                {
                    this.fireEvent('change', this, data);
                
                }
                else
                {
                    this.fireEvent('change', this, Ext.JSON.encode(this.selectedValues.items));    
                }
                
                
            }
        } else {
            var selectedRows = this.resultGrid.getSelectedRows();
            if (selectedRows.length > 0) {
                
                if (this.isGenericPicker === false) {
                    this.selectedValues = new Ext.util.MixedCollection();
                    for (var i = 0; i < selectedRows.length; i++) {
                        var selectedRow = selectedRows[i];
                        if (!this.selectedValues.containsKey(selectedRow.key)) {
                            var data = { key: selectedRow.key, text: selectedRow.text };
                            this.selectedValues.add(data.key, data);

                            if (this.multiSelectPickerList != null) {
                                this.multiSelectPickerList.dom.options.add(new Option(data.text, data.key));
                            }
                        }
                    }
                    
                    if (this.valueEl != null) {
                        if (this.multiSelectPickerList != null) {
                            var pickerList = new Array();
                            for (var i = 0; i < this.multiSelectPickerList.dom.options.length; i++) {
                                pickerList.push({
                                    key: this.multiSelectPickerList.dom.options[i].value,
                                    text: this.multiSelectPickerList.dom.options[i].text
                                });
                            }

                            this.valueEl.dom.value = Ext.JSON.encode(pickerList);
                        }
                        else {
                            this.valueEl.dom.value = Ext.JSON.encode(this.selectedValues.items);
                        }
                    }

                    this.fireEvent('change', this, this.selectedValues.items);
                }
                else
                {
                   this.selectedValues = new Ext.util.MixedCollection();
                   for (var i = 0; i < selectedRows.length; i++) {
                        var selectedRow = selectedRows[i];
                        if (!this.selectedValues.containsKey(selectedRow.key)) {
                            var data = { key: selectedRow.key, text: selectedRow.text };
                            this.selectedValues.add(data.key, data);

                            if (this.multiSelectPickerList != null) {
                                this.multiSelectPickerList.dom.options.add(new Option(data.text, data.key));
                            }
                        }
                    }
                    if (this.valueEl != null) {
                        this.valueEl.dom.value = Ext.JSON.encode(this.selectedValues.items);
                    }

                    this.fireEvent('change', Ext.JSON.encode(this.selectedValues.items));
                }
            }
        }

        this.pickerDialog.close();
    },

    showPickerDialog: function () {
        var urlParams = 'PickerId=' + this.id
                    + '&codeFiltering=' + this.codeFiltering
                    + '&isMultiSelect=' + this.multiSelectPicker;
        if (this.preFilter != null && this.preFilter != '') {
            urlParams += '&prefilter=' + this.preFilter;
        }
        if (this.filter != null && this.filter != '') {
            urlParams += '&filter=' + this.filter;
        }
        if (this.urlParams != null && this.urlParams != '') {
            urlParams += '&' + this.urlParams;
        }

        if (!this.pickerDialog.taskInProgress) {
            this.pickerDialog.urlParams = urlParams;
            this.pickerDialog.show();
        }
    },

    removeSelected: function () {
        while (this.multiSelectPickerList.dom.selectedIndex != -1) {
            this.selectedValues.removeAtKey(this.multiSelectPickerList.dom.options[this.multiSelectPickerList.dom.selectedIndex].value);
            this.multiSelectPickerList.dom.remove(this.multiSelectPickerList.dom.selectedIndex);
        }

        if (this.valueEl != null) {
            this.valueEl.dom.value = Ext.JSON.encode(this.selectedValues.items);
        }
    },

    removeAll: function () {
        while (this.multiSelectPickerList != null && this.multiSelectPickerList.dom.length > 0) {
            this.multiSelectPickerList.dom.remove(0);
        }
        if (this.selectedValues != undefined) {
            this.selectedValues.clear();
        }
        if (this.valueEl != null) {
            this.valueEl.dom.value = null;
        }
    },

    onComboBoxSelected: function (comboBox, selectedRecord) {
        if (this.multiSelectPicker) {
            var selectedValue = comboBox.getValue();
            if (selectedValue[comboBox.valueField] == null || selectedValue[comboBox.valueField] == '' || comboBox.value == null)
                return;

            if (!this.selectedValues.containsKey(selectedValue[comboBox.valueField])) {
                var data = { key: selectedValue[comboBox.valueField], text: selectedValue[comboBox.displayField] };
                this.selectedValues.add(data.key, data);
                this.multiSelectPickerList.dom.options.add(new Option(data.text, data.key));
            }

            if (this.valueEl != null) {
                this.valueEl.dom.value = Ext.JSON.encode(this.selectedValues.items);
            }

            this.fireEvent('change', this, this.selectedValues.items);
        } else {
            this.fireEvent('change', this, selectedRecord);
        }
    },
    onDestroy: function () {
        this.clearListeners(); // added for EXT 6.0
        this.callParent(arguments);
    },

    listeners: {
        'render': function (pickerField, options) {
            if (this.multiSelectPicker) {
                this.selectedValues = new Ext.util.MixedCollection();

                var addButton = Ext.get(this.listId + '_AddButton');
                if (addButton != null) {
                    addButton.on('click', this.showPickerDialog, this);
                }
                var removeButton = Ext.get(this.listId + '_RemoveButton');
                if (removeButton != null) {
                    removeButton.on('click', this.removeSelected, this);
                }
                var removeAllButton = Ext.get(this.listId + '_RemoveAllButton');
                if (removeAllButton != null) {
                    removeAllButton.on('click', this.removeAll, this);
                }
                //this.multiSelectPickerList = Ext.get(this.id + '_list');
                this.multiSelectPickerList = Ext.get(this.listId + '_list');
                if (this.multiSelectPickerList != null) {
                    this.multiSelectPickerList.on('dblclick', this.removeSelected, this);

                    // Populate from current values in the list...
                    for (var i = 0; i < this.multiSelectPickerList.dom.options.length; i++) {
                        var data = { key: this.multiSelectPickerList.dom.options[i].value, text: this.multiSelectPickerList.dom.options[i].text };
                        this.selectedValues.add(data.key, data);
                    }
                }

                if (this.valueElId == null || this.valueElId == '') {
                    this.valueElId = this.id + '_text_multivalue';
                }
            } else if (this.comboBox != null) {
                this.comboBox.on('search', this.showPickerDialog, this);
            }

            if (this.valueElId != null && this.valueElId != '') {
                this.valueEl = Ext.get(this.valueElId);
                if (this.valueEl != null && this.multiSelectPicker != null) {
                    this.valueEl.dom.value = Ext.JSON.encode(this.selectedValues.items);
                }
            }
        }
    }
});

Shr.openTask = function(entityId, sourceComboElId, customUrlParams, onWindowCloseScript) {
    var w = Ext.getBody().getViewSize().width * 0.90;
    var h = Ext.getBody().getViewSize().height * 0.90;

    if (customUrlParams == null || customUrlParams == 'undefined')
        customUrlParams = '';

    var wleft = (screen.width - w) / 2;
    var wtop = (screen.height - h) / 2;

    var win = window.open('PanelViewer.aspx?Entity=' + entityId + customUrlParams, '', 'status=0,scrollbars=1,toolbar=0,menubar=0,resizable=0,location=0,width=' + w + ',height=' + h + ',left=' + wleft + ',top=' + wtop);

    if (sourceComboElId != null || (onWindowCloseScript != null && onWindowCloseScript != '')) {
        Shr._updateComboElId = sourceComboElId;
        Shr._popupWindow = win;
        Shr._onWindowCloseScript = onWindowCloseScript;
        setTimeout(Shr.checkPopup, 1000);
    }
}

Shr.checkPopup = function(onWindowCloseScript) {
    if (Shr._popupWindow != null && !Shr._popupWindow.closed) {
        setTimeout(Shr.checkPopup, 1000);
    } else if (Shr._popupWindow != null) {
        //first we see if the component is of type CodeSelect
        var comboCmp = Ext.getCmp(Shr._updateComboElId + '_CodeSelect');
        //if it is not then try ComboBox
        if (comboCmp == undefined)
        {
            comboCmp = Ext.getCmp(Shr._updateComboElId + '_ComboBox');
        }

        if (comboCmp != null && comboCmp.store != null && comboCmp.mode != 'local') {
            comboCmp.lastQuery = '%%FORCE_CLEAR%%';
            comboCmp.store.removeAll();
        }

        if (Shr._onWindowCloseScript != null && Shr._onWindowCloseScript != '')
            eval(Shr._onWindowCloseScript);

        Shr._updateComboElId = null;
        Shr._popupWindow = null;
        Shr._onWindowCloseScript;
    }
}

Shr.setCookie = function(name, value, days) {
    var expireDate = new Date();
    expireDate.setDate(expireDate.getDate() + days);
    document.cookie = name + '=' + escape(value) + ((days == null) ? '' : ';expires=' + expireDate.toGMTString());
}

Shr.getCookie = function(name) {
    var c_start, c_end;
    if (document.cookie.length > 0) {
        c_start = document.cookie.indexOf(name + '=')
        if (c_start != -1) {
            c_start = c_start + name.length + 1;
            c_end = document.cookie.indexOf(';', c_start);
            if (c_end == -1)
                c_end = document.cookie.length;
            return unescape(document.cookie.substring(c_start, c_end));
        }
    }
    return '';
}

// For a textarea control, enforce a maximum length on the onkeyup event.
// This is necessary because browsers doesn't support the maxlength attribute
// on TextArea controls, so you need to do it programmatically.
Shr.checkTextMaxLength = function (object, maxLength) {
    if (object.value.length > maxLength) {
        object.value = object.value.substring(0, maxLength);
        Ext.MessageBox.alert("Warning", "The allowed amount of characters are " + maxLength +", your text has been truncated");

    }
}

// When a text area control is configured to use a popup for editing instead of an
// in place text area control, then we need to initialize it so that when the user
// clicks on the edit button that a window will open with the appropriate value and
// the user can make changes.  If they cancel out of the popup their changes are reverted
// but if they click save then the display is updated to reflect the new value.  There's
// one tricky part and that has to do with the css styling when the field has a value and
// when it doesn't.  We need to add/remove the shr-text-area-ellipsis-button-absolute css
// class based on the controls value in order to ensure that the edit button is always
// visible.  If the control has no value, then we want to remove this class so that the edit
// button can appear normally within the control's div.  When the control does have a value
// then we want to add that class to force the edit button to be placed using absolute position
// to the right of the control's value.
Shr.configurePopupTextArea = function() {
    return {
            init: function(textAreaElId, textAreaPopupElId, saveLabel, cancelLabel, title) {
                if (textAreaElId != null) {
                    var textAreaEl = Ext.get(textAreaElId);
                    var textAreaPopupEl = Ext.get(textAreaPopupElId);
                    if (textAreaEl == null || textAreaPopupEl == null) 
                        return;

                    var win;
                    var popupLaunch = Ext.get(textAreaPopupEl);
                    if (popupLaunch != null) {
                        popupLaunch.on('click', function() {
                            if (!win) {
                                win = Ext.create('Ext.window.Window', {
                                    layout: 'fit',
                                    closeAction: 'close',
                                    title: title,
                                    closable: false,
                                    modal: true,
                                    floating: true,
                                    fixed: true,
                                    width: 300,
                                    height: 200,
                                    items: [{
                                        xtype: 'textareafield',
                                        value: textAreaEl.dom.innerText,
                                        id: textAreaEl.dom.id + '_textareafield'
                                    }],
                                    buttons: [{
                                        text: saveLabel,
                                        iconCls: "x-fa fa-check",
                                        handler: function() {
                                            if (textAreaEl != null) {
                                                var newValue = Ext.getCmp(textAreaEl.dom.id +'_textareafield').value;
                                                
                                                var hiddenTextRaw = Ext.get(textAreaEl.dom.id + '_text_raw')
                                                if (hiddenTextRaw != null) {
                                                    hiddenTextRaw.dom.value = newValue;
                                                }

                                                var fieldLabel = Ext.get(textAreaEl.dom.id + '_fieldLabel')
                                                if (fieldLabel != null) {
                                                    fieldLabel.dom.title = newValue;
                                                    fieldLabel.dom.innerHTML = newValue;
                                                }

                                            }
                                            if (win != null){
                                                win.close();
                                            }
                                        }
                                    }, { 
                                        text: cancelLabel,
                                        iconCls: "x-fa fa-ban",
                                        handler: function() {
                                            if (win != null) {
                                                win.close();
                                            }
                                        }
                                    }]
                                });
                            }
                            win.show(this);
                        });
                    }
                }
           }
    }
} ();

Shr.showFieldWarningForPicker = function (elId, msg, isMultiSelect, clientID)
{
    var el;
    var float = 'left'; // default
    var errorWidth = 50; //default
    if (isMultiSelect == 'True')
    {
         el = Ext.get(clientID + '_input_div');
    }
    else
    {
        el = Ext.get(clientID);
        float = 'left';
        if (Ext.browser.is.Firefox) 
        {
            errorWidth = 20;
        }
        else
        {
            errorWidth = 5;
        }
    }
    var containerId = 'quickTipContainer_' + elId;
    var container = Ext.getCmp(containerId);
    var errorBtn = new Ext.Button({
            iconCls: 'x-form-invalid-icon-default',
            style: {
                background: 'transparent',
                border: 0,
                padding: 0
            },
            tooltip: msg
    });


    if (container != null) {
        container.add(errorBtn);
    }else{
        Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + elId,
            width: errorWidth,
            style: {
                'float': float
            },
            items: [errorBtn],
            renderTo: el
        });
    }
}

Shr.showFieldWarning = function (elId, msg, type, clientID) {
    /////////////////////////////////////////////////////////////////////////////////////////////

    //The following controls are non-standard so we need to handle warnings differently
    if (type == 'RadioButtonList' || type == 'CheckBox' || type == 'ListSelect' || type == 'HtmlEditor') {
        var el = Ext.get(elId);
        switch (type)
        {
            case 'CheckBox':
                //we need to strip off _fieldCheckBox
                elId = elId.replace('_fieldCheckBox', '')
                el = Ext.get(elId);
                break;
            case 'RadioButtonList':
                break;
            case 'ListSelect':
                break;
            case 'HtmlEditor':
                break;
        }        
        //look for a label class for the control
        var elLabel = el.down('.shr-field-label');
        if (elLabel != null) {
            elp = elLabel;
        }
        else
        {
            if (type == 'ListSelect')
            {
                elp = Ext.get(elId);
                //get the table that the ListSelect is in
                //the first check is for a control that has no label (most common)
                var tableRow = elp.dom.childNodes[0].firstChild.firstChild;
                //now check for one that has a label
                if (tableRow == null)
                {
                    tableRow = elp.dom.childNodes[1].firstChild.firstChild;
                }
                if (tableRow != null) {
                    elp = tableRow;
                }
                else {
                    //show at the bottom
                    elp = Ext.get(elId);
                }
            }
            else
            {
                //show at the bottom
                elp = Ext.get(elId);
            }
        }

        var radioButtonWidth;
        if (type == 'RadioButtonList') {
            elp = Ext.get(elId);
            //this will either be a label or a table    
            var element = elp.dom.childNodes[0];
            radioButtonWidth = element.clientWidth + 5;
        }

        var errorBtn = new Ext.Button({
            iconCls: 'x-form-invalid-icon-default',
            style: {
                background: 'transparent',
                border: 0,
                padding: 0,
                'margin-left': 0
            },
            tooltip: msg
        });
        
        var styleToUse = 'float:right';
        if (type == 'RadioButtonList')
        {
            styleToUse = 'position:absolute;top:3px;left:' + radioButtonWidth + 'px;';
        }

        Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + elId,
            width: 50,
            style: styleToUse,
            items: [errorBtn],
            renderTo: elp
        });
        Ext.QuickTips.init();
        return; // for non-standard controls
    }
    
    if (type == 'EmailTextBox' || type == 'TimeSelect')
    {
        var cmpId = elId.substring(0, elId.lastIndexOf("_") + 1) + 'extCmp';
    }
    else if(type == 'TextArea')
    {
        var cmpId = elId.substring(0, elId.lastIndexOf("_") + 1) + 'textAreafield';
    }
    else
    {
        var cmpId = elId.substring(0, elId.lastIndexOf("_") + 1) + type;
    }

    var cmp = Ext.getCmp(cmpId);
    if (cmp != undefined)
        cmp.markInvalid(msg);
    
    /////////////////////////////////////////////////////////////////////////////////////////////


/*
    if (el == null)
        return;
    var elp;
	//Because the selections are wrapped (including the label) in a div we
	//look for the first child which is the label to add the icon to
    if (type == 'RadioButtonList')
    {
		var elLabel = el.down('.shr-field-label');

		if (elLabel != null)
		{
			elp = elLabel;
		}
		else 
		// if we do not find it then use the default el which will work
		// but the error icon displays below the div (which is better than not displaying at all)
		{
			elp = Ext.get(elId);
		}
    }
    else // default
    {
        elp = el.up(xtype = '.x-form-element');
    }
    /* OLD CODE
    var el = Ext.get(elId);
    if (el == null)
        return;
    var elp = el.findParent('.x-form-element', 6, true);
    var offset = 2;
    if (type == 'CheckBox')
        offset = (elp.getRight() - el.getRight()) - 16;
    el.errorIcon = elp.createChild({ cls: 'x-form-invalid-icon' });

    //Because tooltips are not used for mobile devices we need to show a popup of the
    //warning message.
    if (isHcmMobilePortal == 'true') {
        el.errorIcon.addListener('click', function () {
            Ext.Msg.show({
                title: Shr.LABEL_Warning,
                msg: msg,
                buttons: Ext.Msg.OK,
                icon: Ext.Msg.WARNING
            });
        });
    }
    else {
        el.errorIcon.dom.qtip = msg;
    }
    el.errorIcon.alignTo(el, 'tl-tr', [offset, 0]);
    el.errorIcon.dom.qclass = 'x-form-invalid-tip';
    el.errorIcon.show();

    Ext.QuickTips.init();
   */
/*
   //NEW CODE
    // Create a small panel to add a quick tip to
    var containerId = 'quickTipContainer_' + elId;
    var container = Ext.getCmp(containerId);
    var errorBtn = new Ext.Button({
        iconCls: 'shr-field-error-icon',
        style: {
            background: 'transparent',
            border:0
        },
        tooltip: msg
    });

    var floatStyle = 'right';
    //we need to see if the combobox is in a grid
    //if so then we need to display the error differently
    var grid = el.up('.GridEditRow')
    if (grid !=null && grid.dom.className == 'GridEditRow')
    {
        floatStyle = 'left';
    }

    if (container != null) {
        container.add(errorBtn);
    }else{
        Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + elId,
            width: 50,
            style: {
                'float': floatStyle
            },
            items: [errorBtn],
            renderTo: elp
        });
    }
    /*Ext.tip.QuickTipManager.register({
        target: 'quickTipContainer_' + elId,
        text: msg
    });*/

}

Ext.define('Shr.LayoutManager', {
    singleton: true,
    components: [],
    /*
     *{
     *  component: cmp,
     *  owner: owner
     *}
     */
    addCmp: function (owner, cmp) {
        var me = this;
        if (!me.isRegistered(cmp)) {
            me.trackCmp(owner, cmp);
        }
    },
    trackCmp: function (owner, cmp) {
        var me = this;
        owner.on('afterlayout', Shr.LayoutManager.afterLayout);
        me.components.push({
            component: cmp.id,
            owner: owner.id
        });
    },
    clear: function () {
        var me = this;
        for (var i = 0; i < me.components.length; i++) {
            var item = me.components[i];
            var owner = Ext.getCmp(item.owner);
            owner.un('afterlayout', Shr.LayoutManager.afterLayout);
        }
        me.components = [];
    },
    afterLayout: function (owner, layout, eOp) {
        var me = Shr.LayoutManager;
        for (var i = 0; i < me.components.length; i++) {
            var item = me.components[i];
            if (item.owner == owner.id) {
                var cmp = Ext.getCmp(item.component);
                if (cmp && !cmp.ownerCt) {
                    //console.log('Update Layout: ' + cmp.id);
                    cmp.updateLayout();
                }
            }
        }                    
    },
    removeCmp: function (owner, cmp) {
        var me = this;
        for (var i = 0; i < me.components.length; i++) {
            var item = me.components[i];
            if (item.component == cmp.id) {
                me.components.splice(i, 1);
            }
        }
    },
    isRegistered: function (cmp) {
        var me = this;
        for (var i = 0; i < me.components.length; i++) {
            var item = me.components[i];
            if (item.component == cmp.id) {
                return true;
            }
        }
        return false;
    }
});

Shr.Layout = function () {
    return {
        // Original
        //        init: function (panel) {
        //            panel.on('afterLayout', Shr.Layout.onAfterLayout);
        //            panel.doLayout();
        //        },

        //        onAfterLayout: function (sender) {
        //            var frameHeight = 0;
        //            for (var i = 0; i < sender.items.length; i++) {
        //                var panelHeight = sender.items.items[i].el.getComputedHeight();
        //                if (panelHeight > frameHeight)
        //                    frameHeight = panelHeight
        //            }
        //            if (sender.el.getHeight() != frameHeight) {
        //                sender.setHeight(frameHeight);
        //                sender.doLayout();
        //            }
        //        }


        // New
        init: function (panel) {
            // TODO: Need to remove this once we figure out the real way to get
            // the border layout panel to automatically size according to its content.
            // This only sets the height when rendered and does not work in IE.  If the
            // browser resizes panel does not and if the content is longer than what's
            // visible in browser you can't scroll to see it because of assigning a 
            // height to the panel.

            Shr.LayoutManager.clear();
            MainLayout.trackLayouts();

            panel.autoheight = true;
            
            if (panel.autoheight) {

                var actualHeight = finalHeight = 0;
                var itemId;

                for (var i = 0; i < panel.items.length; i++) {

                    if (panel.items.items[i].items && panel.items.items[i].items.items[0]) {
                        actualHeight = panel.items.items[i].items.items[0].minHeight;

                        if (actualHeight > finalHeight) {
                            finalHeight = actualHeight;
                        }
                    } else if (panel.items.items[i].contentEl != null && panel.items.items[i].contentEl != "undefined") {
                        actualHeight = document.getElementById(panel.items.items[i].contentEl.id).offsetHeight;

                        panel.items.items[i].contentEl.on('resize', function (el, info, eOpts) {
                            //The code below insures that if the content panel is larger than the section list then set the height to the height of the content panel.
                            //This avoids truncation of the content panel (requisition setup task for example).
                            //But if the content panel is smaller than the section list we do NOT want to set the height to the content panel because that will truncate the section list
                            if (actualHeight < el.dom.offsetHeight && el.dom.offsetHeight > panel.getHeight()) {
                                panel.setHeight(el.dom.offsetHeight);
                            }
                            
                        });

                        if (actualHeight > finalHeight) {
                            finalHeight = actualHeight;
                        }
                    }
                }
                var mainLayoutPanels = MainLayout.getFrameLayout();

                if (mainLayoutPanels) {
                    panel.setHeight(finalHeight);
                    mainLayoutPanels.on('resize', Shr.Layout.onMainLayoutResize, panel);
                }
                else {
                    panel.setHeight(finalHeight + 20);
                    panel.updateLayout();
                    Ext.on('resize', Shr.Layout.onPanelResize, panel);
                }
            }

        },
        onPanelResize: function () {
            Shr.Layout.autoSizePanel(this);
        },

        onMainLayoutResize: function () {
            Shr.Layout.autoSizeLayout(this);
        },

        autoSizeLayout: function (panel) {
            var mainLayoutPanels = MainLayout.getFrameLayout();
            if (mainLayoutPanels != null) {
                
                mainLayoutPanels.updateLayout();
                panel.updateLayout();
                if (panel.items.items[0].contentEl) {
                    actualHeight = document.getElementById(panel.items.items[0].contentEl.id).offsetHeight;
                    document.getElementById(panel.items.items[0].id + "-body").style.height = actualHeight.toString() + "px";
                }
                

            }
        },
        autoSizePanel: function (panel) {
            panel.updateLayout();
            if (panel.items.items && panel.items.items.length > 0 && panel.items.items[0].contentEl) {
                actualHeight = document.getElementById(panel.items.items[0].contentEl.id).offsetHeight;
                document.getElementById(panel.items.items[0].id + "-body").style.height = actualHeight.toString() + "px";
            }
            
        }
    };
}();

Shr.commandClicked = function(elementId) {
    var el = Ext.get(elementId);
    if (el != null) {
        var confirmText = el.dom.getAttribute('confirmText');
        var postbackCommand = el.dom.getAttribute('postbackCommand');
        var handleResult = function(result) {
            if (result == 'yes') {
                var postbackCommand = this.dom.getAttribute('postbackCommand');
                
                //The form object gets set to undefined when Shr.Async.Update() is ran so we need to reset it here
                if (theForm == undefined)
                {
                    theForm = document.forms['aspnetForm'];
                }
                eval(postbackCommand);
            }
        };

        if (confirmText != null && postbackCommand != null) {
            var confirmMsg = Ext.MessageBox.confirm(Shr.LABEL_Confirm, confirmText, handleResult, el);

            confirmMsg.setKeyMap({
                N: {
                    handler: function () { confirmMsg.close(); },
                    scope: this
                },
                Y: {
                    handler: function () { confirmMsg.close(); eval(postbackCommand); },
                    scope: this
                }
            });
        }
        else if (postbackCommand != null) {
            //The form object gets set to undefined when Shr.Async.Update() is ran so we need to reset it here
            if (theForm == undefined)
            {
                theForm = document.forms['aspnetForm'];
            }
            eval(postbackCommand);
        }
    }
}

Shr.changePrompt = function(elId, textElId, hiddenElementId, promptType, controlType, title, text) {
    var el = Ext.get(elId);
    if (el == null) {
        return;
    }

    var textEl = Ext.get(textElId);
    if (textEl == null) {
        return;
    }

    // If the field is currently empty, don't show the prompt.
    var elCmp = Ext.getCmp(textElId);
    if (elCmp != null
        && promptType != 'ConfirmRunFunction'
        && promptType != 'YesNoCancel'
        && (elCmp.originalValue == null || elCmp.originalValue == '')) {

        Shr.queueDelayedPostBack(elId);
        return;
    }

    if (Shr._promptChangeExecuting != null) 
        return;
    Shr._promptChangeExecuting = window.event;

    if (promptType == 'Notify') {
        Ext.MessageBox.alert(title, text);
        Shr._promptChangeExecuting = null;
    } else if (promptType == 'CancelAndResetValue') {
        Ext.Msg.show({
            title: title,
            msg: text,
            buttons: Ext.Msg.OKCANCEL,
            fn: function(buttonName) {
                if (buttonName == 'ok') {
                    Shr.queueDelayedPostBack(elId);
                } else if (elCmp != null) {
                    elCmp.reset();
                }
                Shr._promptChangeExecuting = null;
            },
            icon: Ext.MessageBox.Question
        });
    } else if (promptType == 'Cancel') {
        Ext.Msg.show({
            title: title,
            msg: text,
            buttons: Ext.Msg.OKCANCEL,
            fn: function(buttonName) {
                if (buttonName == 'ok') {
                    Shr.queueDelayedPostBack(elId);
                }
                Shr._promptChangeExecuting = null;
            },
            icon: Ext.MessageBox.Question
        });
    } else if (promptType == 'ConfirmRunFunction') {
        if (el.dom.value == '')
            return;

        Ext.Msg.show({
            title: title,
            msg: text,
            buttons: Ext.Msg.YESNO,
            fn: function(buttonName) {
                var hidEl = Ext.get(hiddenElementId);
                if (buttonName == 'no') {
                    hidEl.dom.value = 'cancel';
                }
                Shr.queueDelayedPostBack(elId);
                Shr._promptChangeExecuting = null;
            },
            icon: Ext.MessageBox.Question
        });
    } else if (promptType == 'YesNoCancel') {
        if (el.dom.value == '')
            return;

        Ext.Msg.show({
            title: title,
            msg: text,
            buttons: Ext.Msg.YESNOCANCEL,
            fn: function(buttonName) {
                var hidEl = Ext.get(hiddenElementId);
                if (buttonName == 'cancel') {
                    if (elCmp != null) {
                        elCmp.reset();
                    }
                } else {
                    hidEl.dom.value = buttonName;
                    Shr.queueDelayedPostBack(elId);
                }

                Shr._promptChangeExecuting = null;
            },
            icon: Ext.MessageBox.Question
        });
    } else {
        Shr._promptChangeExecuting = null;
    }
}

Shr.toggleExpandCollapse = function(cell, contentElId) {
    var el = Ext.get(cell);
    var contentEl = Ext.select('div[id="' + contentElId + '"]');

    if (contentEl === null)
        contentEl = Ext.get(contentElId);

    if (el.hasCls('collapse')) {
        el.removeCls('collapse');
        el.addCls('expand');
        el.setHtml("<i class='x-fa fa-plus-square-o'></i>");

        if (contentEl != null)
            contentEl.addCls('shr-displaynone');
    } else {
        el.removeCls('expand');
        el.addCls('collapse');
        el.setHtml("<i class='x-fa fa-minus-square-o'></i>");

        if (contentEl != null) {
            contentEl.removeCls('shr-displaynone');
            var component = Shr.getComponentFromElement(Ext.get(contentElId).dom);
            if (component) {
                component.updateLayout();
            }
        }
    }

    //Call to resize the content main panel.
    MainLayout.updateLayout();

    return true;
}

Shr.getComponentFromElement = function findComponentByElement(node) {
    var topmost = document.body,
        target = node,
        cmp;

    while (target && target.nodeType === 1 && target !== topmost) {
        cmp = Ext.getCmp(target.id);

        if (cmp) {
            return cmp;
        }

        target = target.childNodes[0];
    }

    return null;
}

Shr.showHideFilter = function(cell, contentElId) {
    var contentEl = Ext.get(contentElId);

    if (contentEl != null) {
        if(contentEl.hasCls('shr-displaynone')) {
            contentEl.removeCls('shr-displaynone');
        } else {
            contentEl.addCls('shr-displaynone');
        }
        
        //call updatePanel of container panel
        //to resizing according new size of content.
        MainLayout.updateLayout();      
    }  
    
    return true;
}

// Queues a delayed postback for a control so it will fire after a short
// period. This is so if there is an on-change for a control it won't fire
// immediately, in case the user did something else that will cause a postback
// and so if the focus moved to another control then focus on return will be
// on the new focus control. This delayed postback can be cancelled by setting
// the _pendingPostBackTarget variable to null.
Shr._pendingPostBackTarget = null;
Shr._pendingPostBackArgs = null;
Shr.queueDelayedPostBack = function(elId, args) {
    Shr._pendingPostBackTarget = elId;
    Shr._pendingPostBackArgs = args;
    setTimeout(Shr.doDelayedPostBack, 150);
},

Shr.doDelayedPostBack = function() {
    if (Shr._pendingPostBackTarget != null) {
        var target = Shr._pendingPostBackTarget;
        var args = Shr._pendingPostBackArgs;
        Shr._pendingPostBackTarget = null;
        Shr._pendingPostBackArgs = null;

        __doPostBack(target, args);
    }
}

Shr.updateUrlParams = function(urlParams) {
    window.location.search = '?' + urlParams;
    return false;
}

Shr.salaryPlanningAmountFrequencyPercent = function(amountElementId, frequencyElementId, percentElementId, changeType, title, message) {
    var TaskExecute_SectionControl_promptChangeEvent = null;
    var showPrompt = false;
    var postback = false;
    if (changeType == 'amount') {
        var combo = Ext.getCmp(frequencyElementId);
        var elPercent = document.getElementById(percentElementId);
        if ((typeof combo.value != 'undefined') && (combo.value != '') && (elPercent.value != '')) {
            showPrompt = true;
        }
        else {
            if ((typeof combo.value != 'undefined') && (combo.value != '')) {
                postback = true;
            }
        }
    }
    else if (changeType == 'frequency') {
        var elAmount = document.getElementById(amountElementId);
        var elPercent = document.getElementById(percentElementId);
        if ((elAmount.value != '') && (elPercent.value != '')) {
            showPrompt = true;
        }
        else {
            if (elAmount.value != '') {
                postback = true;
            }
        }
    }
    else if (changeType == 'percent') {
        var elAmount = document.getElementById(amountElementId);
        var combo = Ext.getCmp(frequencyElementId);
        if ((elAmount.value != '') || ((typeof combo.value != 'undefined') && (combo.value != ''))) {
            showPrompt = true;
        }
        else {
            postback = true;
        }
    }
    if (!TaskExecute_SectionControl_promptChangeEvent) {
        TaskExecute_SectionControl_promptChangeEvent = window.event;
        if (showPrompt) {
            Ext.Msg.show({
                title: title,
                msg: message,
                buttons: Ext.Msg.OKCANCEL,
                fn: function(buttonName) {
                    if (buttonName == 'ok') {
                        if (changeType != 'percent') {
                            var elPercent = document.getElementById(percentElementId);
                            elPercent.value = '';
                            __doPostBack(amountElementId);
                        }
                        else {
                            var elAmount = document.getElementById(amountElementId);
                            elAmount.value = '';
                            var combo = Ext.getCmp(frequencyElementId);
                            combo.setValue('');
                            __doPostBack(percentElementId);
                        }
                    }
                    else {
                        if (changeType == 'percent') {
                            var elPercent = document.getElementById(percentElementId);
                            elPercent.value = '';
                        }
                        else {
                            var elAmount = document.getElementById(amountElementId);
                            elAmount.value = '';
                            var combo = Ext.getCmp(frequencyElementId);
                            combo.setValue('');
                        }
                    }
                    TaskExecute_SectionControl_promptChangeEvent = null;
                },
                icon: Ext.MessageBox.Question
            });
        }
        else {
            if (postback) {
                __doPostBack(amountElementId);
            }
        }
    }
}

Shr.Async = function() {
    return {
        load : function(containerId, controlName) {
            var containerEl = Ext.get(containerId);
            if(containerEl != null) {
                // Remember the original __doPostBack function, because when we
                // load the new ASP.NET page, it'll overwrite it with a new one!
                if(typeof __doPostBack != 'undefined') {
                    Shr.originalDoPostBackFn = __doPostBack;
                }

                containerEl.load({
                    url: getPathRoot() + '/API/ControlFetcher.aspx?source=' + controlName + '&container=' + containerId, 
                    method: 'GET',
                    scripts: true,
                    text: Ext.form.field.ComboBox.prototype.loadingText,
                    callback: function(el, success, response, options) {
                        // After the callback completes, restore the original __doPostBack
                        // function, so the page and ASP.NET AJAX will function properly.
                        // We also need to restore the form target for the postbacks to
                        // the main form on the document, not the form on the picker page.
                        __doPostBack = Shr.originalDoPostBackFn;
                        theForm = document.forms['aspnetForm'];
                    }
                });
            }
        },

        update : function(containerId, controlName, urlParams, showMask, method, postParams, ignoreValidate) {
            var containerEl = Ext.get(containerId);

            if(containerEl != null) {
                // Remember the original __doPostBack function, because when we
                // load the new ASP.NET page, it'll overwrite it with a new one!
                if(typeof __doPostBack != 'undefined') {
                    Shr.originalDoPostBackFn = __doPostBack;
                }
                
                var whichControlFetcher= (typeof(ignoreValidate) !== undefined && ignoreValidate) 
                                                        ? '/API/NonValidatingControlFetcher.aspx?source='
                                                        : '/API/ControlFetcher.aspx?source=' ;
                                                        
                var url = getPathRoot() + whichControlFetcher + controlName + '&container=' + containerId + urlParams;

                // Ext 4.0.2a no longer contains Ext.Updater.  It's been replaced by Ext.ElementLoader, 
                // which does not contain the ability to specify defaults.  Leaving this here for now
                // for reference and in case we find a way to set the new 4.0.2a property equivalent.
                // Force the updater to disable caching so each request is actually made, and Ext
                // doesn't retrieve the results of previous requests with the same URL.


                // Set the panel to NOT show the 'Loading...' message during AJAX
                // updates, since this causes the element to clear and screen size
                // to change, which results in flicker and loss of position.
                //var um = containerEl.getUpdater();//Ext 3.4.2

                // Create a mask to show over the container while we're doing the
                // AJAX call. The load indicator doesn't work well, because the
                // element is sort of collapsed while loading, so there's a flicker.
                if(showMask == true) {
                    asynchMask = new Ext.LoadMask(containerEl, { removeMask: true }); //Ext 3.4.2
                    asynchMask = Ext.getBody().mask(Shr.LABEL_Loading);
                    asynchMask.show();
                }
                //um.showLoadIndicator = false; //Ext 3.4.2
                containerEl.load({
                    url: url,
                    method: typeof(method) === 'undefined' ? 'GET' : method,            
                    scripts: true,
                    params: postParams,
                    callback: function(el, success, response, options) {
                        // After the callback completes, restore the original __doPostBack
                        // function, so the page and ASP.NET AJAX will function properly.
                        // We also need to restore the form target for the postbacks to
                        // the main form on the document, not the form on the picker page.
                        __doPostBack = Shr.originalDoPostBackFn;
                        theForm = document.forms['aspnetForm'];
                        
                        // Destroy the mask shown during the AJAX call.
                        if (typeof asynchMask != "undefined") {
                            Shr.destroyLoadMaskComponents(asynchMask);
                            asynchMask = null;
                        }
                    }
                });
            }
        },

        queueUpdate : function(msDelay, containerId, controlName, urlParams) {
            Shr.Async._queuedContainerId = containerId;
            Shr.Async._queuedControlName = controlName;
            Shr.Async._queuedUrlParams = urlParams;
            setTimeout(Shr.Async.doDelayedUpdate, msDelay);
        },

        doDelayedUpdate : function() {
            if(Shr.Async._queuedContainerId != null) {
                Shr.Async.update(Shr.Async._queuedContainerId, Shr.Async._queuedControlName, Shr.Async._queuedUrlParams);

                Shr.Async._queuedContainerId = null;
                Shr.Async._queuedControlName = null;
                Shr.Async._queuedUrlParams = null;
            }
        }
    };
}();

Shr.setEmailLink = function(emailLinkEl, emailAddressEl) {
    var emailLink = Ext.get(emailLinkEl);
    if (emailLink != null) {
        var emailAddressTextBox = Ext.get(emailAddressEl);
        if (emailAddressTextBox != null) {
            emailLink.dom.href = 'mailto:' + emailAddressTextBox.getValue();
        }
    }
}

Shr.GridStates = [];
Shr.Grid = function(elId, clientRowHighlight, clientRowSelect, onClientCreated) {
    this.id = elId;
    this.rowHighlight = clientRowHighlight;
    this.rowSelect = clientRowSelect;
    this._rows = [];
    this._currentRow = null;

    this.el = Ext.get(this.id);

    if (this.rowSelect != 'None') {
        this._selectedRows = [];
    }

    this.initGrid();

    if (onClientCreated != null) {
        onClientCreated(this);
    }
};


Shr.Grid.prototype.initGrid = function () {
    if (this.rowHighlight == true || this.rowSelect != 'None') {
        this.el.select('.GridRow, .GridAltRow', true).each(function (rowEl) {
            if (this.rowHighlight == true) {
                rowEl.addClsOnOver('x-grid3-row-over');
            }
            if (this.rowSelect != 'None') {
                rowEl.unselectable();
                rowEl.on('click', this.rowClicked, this);
            }
        }, this);
        
        if (this.rowSelect != 'None') {
            var tableEl = Ext.select('.GridDataTable');
            var n = tableEl.elements.length.toString() - 1;
            if (tableEl.elements[n]) {
                for (var i = 0; tableEl != null && i < tableEl.elements[n].childNodes.length; i++) {
                    var childRow = tableEl.elements[n].children[i];
                    var childRowKey = childRow.getAttribute('key');
                    if (childRowKey != null && childRowKey != '') {
                        var childRowEl = Ext.get(childRow);
                        var childRowText = childRow.getAttribute('text');
                        this._rows.push({ el: childRowEl, key: childRowKey, text: childRowText });
                    }
                }
            }
        }
    }

    if (Shr.GridStates[this.id] == null) {
        Shr.GridStates[this.id] = [];
    }
    this.gridState = Shr.GridStates[this.id];

    if (Ext.select('.Expand, .Collapse') != null) {
        this.el.select('TR', true).each(function (rowEl) {
            var btnEl = rowEl.child('.Expand, .Collapse');
            if (btnEl != null) {
                var rowKey = rowEl.dom.getAttribute('key');
                if (rowKey != null) {
                    if (this.gridState[rowKey] == 1 && btnEl.hasCls('Expand')) {
                        btnEl.replaceCls('Expand', 'Collapse');
                    } else if (this.gridState[rowKey] == 0 && btnEl.hasCls('Collapse')) {
                        btnEl.replaceCls('Collapse', 'Expand');
                    }
                }
            }
        }, this);

        this.el.select('.Expand, .Collapse', true).each(function (btnEl) {
            btnEl.on('click', this.toggleExpandCollapse, this);
            if (btnEl.hasCls('Expand')) {
                this.collapseChildren(btnEl);
            }
        }, this);
    }
    if (this.el.child('INPUT[type=text]') != null) {
        if (!Ext.isIE) {
            Ext.EventManager.onWindowResize(this.onResize, this);
            setTimeout(Ext.bind(function () { this.onResize(); }, this), 750);
        } else {
            this.el.on('resize', this.onResize, this);
            setTimeout(Ext.bind(function () { this.onResize(); }, this), 50);
        }
    }

    if (this.onGridInit) {
        this.onGridInit(this);
    }
};

Shr.Grid.prototype.getRows = function() {
    return this._rows;
};

Shr.Grid.prototype.setCurrentRow = function(rowInfo) {
    this._currentRow = rowInfo;
    this.selectRow(rowInfo);
};

Shr.Grid.prototype.getCurrentRow = function() {
    return this._currentRow;
};

Shr.Grid.prototype.clearSelections = function() {
    if (this.rowSelect == 'None') 
        return;

    for(var i = 0; i < this._selectedRows.length; i ++) {
        this._selectedRows[i].el.removeCls('SelectedRow');
    }
    this._selectedRows = [];
};

Shr.Grid.prototype.selectAll = function() {
    if (this.rowSelect == 'None') 
        return;

    this._selectedRows = [];
    for(var i = 0; i < this._rows.length; i ++) {
        this.selectRow(this._rows[i]);
    }
};

Shr.Grid.prototype.selectRow = function(rowInfo) {
    if (rowInfo == null) 
        return;

    rowInfo.el.addCls('SelectedRow');
    this._selectedRows.push(rowInfo);
};

Shr.Grid.prototype.selectRowEl = function(rowEl) {
    for(var i = 0; i < this._rows.length; i ++) {
        if(this._rows[i].el == rowEl) {
            this.selectRow(this._rows[i]);
            return this._rows[i];
        }
    }

    return null;
};

Shr.Grid.prototype.getSelectedRows = function() {
    return this._selectedRows;
};

Shr.Grid.prototype.rowClicked = function(e, t) {
    var clickedEl = Ext.get(t);
    if (clickedEl == null) 
        return;
    var rowEl = clickedEl.findParent('TR', 6, true);
    if (rowEl == null) 
        return;
    var rowKey = rowEl.dom.getAttribute('key');
    if (rowKey == null || rowKey == '') 
        return;

    if(e.ctrlKey == true && this.rowSelect == 'Multiple') {
        var selectedIndex = -1;
        for(var i = 0; i < this._selectedRows.length && selectedIndex == -1; i ++) {
            if(this._selectedRows[i].el == rowEl) {
                selectedIndex = i;
            }
        }

        if(selectedIndex > -1) {
            rowEl.removeCls('SelectedRow');
            this._selectedRows.splice(selectedIndex, 1);
            this._currentRow = null;
        } else {
            this._currentRow = this.selectRowEl(rowEl);
        }
    } else if(e.shiftKey == true && this._currentRow != null && this.rowSelect == 'Multiple') {
        this.clearSelections();

        var foundStart = false;
        var foundEnd = false;
        for(var i = 0; i < this._rows.length && foundEnd == false; i ++) {
            if(foundStart == false && (this._rows[i] == this._currentRow || this._rows[i].el == rowEl)) {
                foundStart = true;
                this.selectRow(this._rows[i]);
            } else if(foundStart == true && (this._rows[i] == this._currentRow || this._rows[i].el == rowEl)) {
                this.selectRow(this._rows[i]);
                this._currentRow = this._rows[i];
                foundEnd = true;
            } else if(foundStart == true) {
                this.selectRow(this._rows[i]);
            }
        }
    } else {
        this.clearSelections();
        this._currentRow = this.selectRowEl(rowEl);
    }
};

Shr.Grid.prototype.onResize = function(e) {
    this.el.select('.shr-field INPUT[type=text]', true).each(function(inputEl) {
        var inputCmp = Ext.getCmp(inputEl.dom.id);
        var w = inputEl.findParent('TD').offsetWidth;
        if (inputCmp != null) {
            inputCmp.setWidth(w - 20);
        } else {
            inputEl.setWidth(w - 10);
        }
    });
};

Shr.Grid.prototype.toggleExpandCollapse = function(e) {
    var cellEl = Ext.get(e.target.id);
    
    if (cellEl.hasCls('Expand')) {
        cellEl.replaceCls('Expand', 'Collapse');
        this.expandChildren(cellEl);

        if(!Ext.isIE) {
            this.onResize();
        }
    } else {
        cellEl.replaceCls('Collapse', 'Expand');
        this.collapseChildren(cellEl);
    }

    var viewport = MainLayout.getFrameLayout(); 
    if (viewport) {
        viewport.updateLayout();
    }

};

Shr.Grid.prototype.collapseChildren = function(clickedEl) {
    var row = clickedEl.parent();
    var rowKey = row.dom.getAttribute('key');
    this.gridState[rowKey] = 0;

    var buttonIndex = -1;
    for(var i = 0; i < row.dom.childNodes.length; i ++) {
        if(row.dom.childNodes[i] == clickedEl.dom) { 
            buttonIndex = i;
            break;
        }
    }
    if (buttonIndex == -1) 
        return;

    var sibling = row.next();
    var doExit = false;
    while(sibling != null && doExit == false) {
        if(sibling.hasCls('GridFooter')) {
            doExit = true;
            break;
        }
    
        for(var i = 0; i < sibling.dom.childNodes.length && i <= buttonIndex; i ++) {
            var cell = Ext.get(sibling.dom.childNodes[i]);
            if(cell.hasCls('Expand') || cell.hasCls('Collapse')) {
                doExit = true;
                break;
            }
        }

        if(doExit == false) {
            sibling.setDisplayed('none');
            sibling = sibling.next();
        }
    }
};

Shr.Grid.prototype.expandChildren = function(clickedEl) {
    var row = clickedEl.parent();
    var rowKey = row.dom.getAttribute('key');
    this.gridState[rowKey] = 1;

    var buttonIndex = -1;
    for(var i = 0; i < row.dom.childNodes.length; i ++) {
        if(row.dom.childNodes[i] == clickedEl.dom) { 
            buttonIndex = i;
            break;
        }
    }
    if (buttonIndex == -1) 
        return;

    var sibling = row.next();
    var doExit = false;
    while(sibling != null && !doExit) {
        for(var i = 0; i < sibling.dom.childNodes.length && i <= buttonIndex; i ++) {
            var cell = Ext.get(sibling.dom.childNodes[i]);
            if(cell.hasCls('Expand') || cell.hasCls('Collapse')) {
                doExit = true;
                break;
            }
        }

        if(!doExit) {
            sibling.setDisplayed(true);
            sibling = sibling.next();
        }
    }

    sibling = row.next();
    doExit = false;
    while(sibling != null && !doExit) {
        for(var i = 0; i < sibling.dom.childNodes.length && i <= buttonIndex; i ++) {
            var cell = Ext.get(sibling.dom.childNodes[i]);
            if(cell.hasCls('Expand') || cell.hasCls('Collapse')) {
                doExit = true;
                break;
            }
        }

        if(!doExit) {
            var collapseNode = sibling.child('.Expand');
            if(collapseNode != null) {
                this.collapseChildren(collapseNode);
            }
            sibling = sibling.next();
        }
    }
};


// Asynchronously updates data based onchange event of control via ../API/DataUpdate.aspx
Shr.asynchDataUpdate = function(extCmpID, elementId) {
    var cmp = Ext.getCmp(extCmpID);
    var controlEl = Ext.get(elementId);


    //the checkbox is not an EXT control so...
    if (cmp == null && controlEl != null)
    {
        controlEl = Ext.getDom(elementId); // we are getting the dom because the attributes are on the input field itself
        var key = controlEl.attributes['key'].value;
        var dataType = controlEl.attributes['datatype'].value;
        var property = controlEl.attributes['property'].value;
        var jsonFn = controlEl.attributes['jsonfn'].value;
        var draft = null;
        var controlType = controlEl.attributes['controlType'].value;

        var value = controlEl.checked ? 1 : 0;

        // Proceed with data update
        var url = getPathRoot() + '/API/JsonFetcher.svc/Invoke';
        var params = { svcprovider: jsonFn, key: key, type: dataType, property: property, value: value, draft: draft };
        Ext.Ajax.request({
            loadmask: false,
            url: url,
            params: params,
            success: function(response) {
                try {
                    var onAjaxResultReturned = controlEl.attributes['onajaxresultreturned'].value;
                    if (onAjaxResultReturned != null) {
                        var jsonResult = Ext.decode(response.responseText);
                        var fn = eval(onAjaxResultReturned);
                        fn(jsonResult);
                    }
                }
                catch (ex) { }
            },
            failure: function() {
                Ext.Msg.show({
                    title: Shr.LABEL_Error,
                    msg: Shr.LABEL_ConnectionTimeout,
                    buttons: Ext.Msg.OK,
                    icon: Ext.Msg.ERROR,
                    fn: function() {
                        TaskExecute.suppressNavigatePostback();
                        document.location.reload();
                    }
                });
            }
        });

        return false;
    }
    else if (cmp != null && controlEl != null)
    {
        //kdm01 begin

        if (Ext.get(elementId + '-inputCmp-textareaEl') != null) {  //kdm02  - this -inputCmp is only defined for htmleditor types.
        //kdm02 var onClientChangeField = Ext.get(elementId + '_hdnOnClientChangeField');
            var onClientChangeField = Ext.get(controlEl.id.replace('_htmlEditor', '_hdnOnClientChangeField'));   //kdm02    
            if (onClientChangeField != null) {
                //kdm02 begin
                //key = Ext.get(elementId + '_hdnKeyField').dom.value;
                //dataType = Ext.get(elementId + '_hdnDatatypeField').dom.value;
                //property = Ext.get(elementId + '_hdnPropertyField').dom.value;
                //jsonFn = Ext.get(elementId + '_hdnJsonFnField').dom.value;
                var key = Ext.get(controlEl.id.replace('_htmlEditor', '_hdnKeyField')).dom.value;
                var dataType = Ext.get(controlEl.id.replace('_htmlEditor', '_hdnDatatypeField')).dom.value;
                var property = Ext.get(controlEl.id.replace('_htmlEditor', '_hdnPropertyField')).dom.value;
                var jsonFn = Ext.get(controlEl.id.replace('_htmlEditor', '_hdnJsonFnField')).dom.value;
                var draft = null;
                var onAjaxResultReturnedFn = null;
                //kdm02  controlType = 'htmleditor'; -- we don't need this since we are checking the -inputCmp to see if it is htmleditor type
                //kdm02 end

                // For certain control types, the actual value is stored in a separate hidden
                // control so we cannot just get the value from controlEl.  Instead we look at
                // the controlEl, which in these cases has a custom attribute identifying which
                // control holds the value.  We cannot just rely on the hidden control to provide
                // all of the custom attributes because you cannot add custom attributes to a
                // HiddenField control.
                var value = null;
                //if the type of control is a combobox then we look at the hidden field xxx_text_value value's property and NOT xxx_text value's property 

                //kdm02 var textbox = Ext.get(elementId + '_HTMLEDIT');
                var textbox = Ext.get(elementId + '-inputCmp-textareaEl');   //kdm02 -- get the hidden field
                if (textbox != null) {
                    value = textbox.dom.value;
                }

                // Proceed with data update
                var url = getPathRoot() + '/API/JsonFetcher.svc/Invoke';
                var params = { svcprovider: jsonFn, key: key, type: dataType, property: property, value: value, draft: draft };
                Ext.Ajax.request({
                    loadmask: false,
                    url: url,
                    params: params,
                    success: function (response) {
                        try {
                            var onAjaxResultReturned = onAjaxResultReturnedFn;
                            //kdm01 begin
                            var onajaxresultreturnedfield = Ext.get(elementId + '_hdnOnAjaxResultReturned');
                            if (onajaxresultreturnedfield != null) {
                                onAjaxResultReturned = onajaxresultreturnedfield.dom.value;
                            }
                            //kdm01 end

                            if (onAjaxResultReturned != null) {
                                if (response.responseText !== '') {
                                    var jsonResult = Ext.decode(response.responseText);
                                    var fn = eval(onAjaxResultReturned);
                                    fn(jsonResult);
                                }
                            }
                        }
                        catch (ex) { }
                    },
                    failure: function () {
                        Ext.Msg.show({
                            title: Shr.LABEL_Error,
                            msg: Shr.LABEL_ConnectionTimeout,
                            buttons: Ext.Msg.OK,
                            icon: Ext.Msg.ERROR,
                            fn: function () {
                                TaskExecute.suppressNavigatePostback();
                                document.location.reload();
                            }
                        });
                    }
                });
            }
        }
        else
        {
            //kdm01 end -- original code below
            var key = cmp.inputFieldAttributes.key;
            var dataType = cmp.inputFieldAttributes.datatype;
            var property = cmp.inputFieldAttributes.property;
            var jsonFn = cmp.inputFieldAttributes.jsonfn;
            var draft = cmp.inputFieldAttributes.draft;
            var controlType = cmp.inputFieldAttributes.controlType;
            var onAjaxResultReturnedFn = cmp.inputFieldAttributes.onajaxresultreturned;

            // For certain control types, the actual value is stored in a separate hidden
            // control so we cannot just get the value from controlEl.  Instead we look at
            // the controlEl, which in these cases has a custom attribute identifying which
            // control holds the value.  We cannot just rely on the hidden control to provide
            // all of the custom attributes because you cannot add custom attributes to a
            // HiddenField control.
            value = null;
            //if the type of control is a combobox then we look at the hidden field xxx_text_value value's property and NOT xxx_text value's property 
            if (controlType == 'combobox') {
                controlEl = Ext.get(elementId + "_value");
            }
            if (controlEl.dom.getAttribute('valueControlId') != null) {
                var valueControlEl = Ext.get(controlEl.dom.getAttribute('valueControlId'));
                if (valueControlEl != null)
                    value = valueControlEl.getValue();
            } else {
                if (controlEl.dom.type == 'checkbox')
                    value = controlEl.dom.checked ? 1 : 0;
                else
                    value = controlEl.getValue();
            }

            // Proceed with data update
            var url = getPathRoot() + '/API/JsonFetcher.svc/Invoke';
            var params = { svcprovider: jsonFn, key: key, type: dataType, property: property, value: value, draft: draft };
            Ext.Ajax.request({
                loadmask: false,
                url: url,
                params: params,
                success: function (response) {
                    try {
                        var onAjaxResultReturned = onAjaxResultReturnedFn;

                        if (onAjaxResultReturned != null) {
                            if (response.responseText !== '') {
                                var jsonResult = Ext.decode(response.responseText);
                                var fn = eval(onAjaxResultReturned);
                                fn(jsonResult);
                            }
                        }
                    }
                    catch (ex) { }
                },
                failure: function () {
                    Ext.Msg.show({
                        title: Shr.LABEL_Error,
                        msg: Shr.LABEL_ConnectionTimeout,
                        buttons: Ext.Msg.OK,
                        icon: Ext.Msg.ERROR,
                        fn: function () {
                            TaskExecute.suppressNavigatePostback();
                            document.location.reload();
                        }
                    });
                }
            });
        } //kdm01
       
        return false;
    }
}

Shr.panels.Helper = function() { }

Shr.panels.Helper.postLoad = function(control, formId, contentPanel, callback) {
    var formParams = getFormValues(formId);
    var cmp = Ext.getCmp(contentPanel);
    cmp.loader =
    {
        loadMask: true,
        url: control,
        params: formParams,
        scripts: true
    };
    cmp.getLoader().load();
    }

// Used for toggle div with expand/collapse img
Shr.Util.ToggleCollapse = function (elId, toggleIcon) {
    var el = Ext.get(elId)
    var toggleIcon = Ext.get(toggleIcon)

    if (el.isVisible()) {
        toggleIcon.replaceCls("fa-minus-square-o", "fa-plus-square-o")
        el.setVisible(false, false);
    } else {
        toggleIcon.replaceCls("fa-plus-square-o", "fa-minus-square-o")
        el.setVisible(true, true);
    }
}

Ext.define('Shr.PopHeaderPanel', {
    extend: 'Ext.panel.Panel',
    iconClass: '',
    headerTitle: '',
    headerText: '',
    initComponent: function () {
        var config = {
            height: 80,
            layout: {
                type: 'hbox',       // Arrange child items vertically
                align: 'stretch',    // Each takes up full width
                padding: 5
            },
            items: [{
                baseCls: 'x-plain',
                html: '<i class="shr-pop-header-img ' + this.iconClass + '"></i>',
                flex: 0 
            },
            {
                layout: {
                    type: 'vbox',       // Arrange child items vertically
                    align: 'stretch',    // Each takes up full width
                    padding: 5                    
                },
                flex: 2,
                border: false,
                items: [{
                        xtype: 'label',
                        text: this.headerTitle,
                        style : 'font-size: 20px;',
                        margin: '10 0 0 10'
                    },{
                        xtype: 'label',
                        text: this.headerText,
                        margin: '5 0 0 10'
                    }
                ]
            }]
        };

        Ext.apply(this, config, this.initialConfig);
        Shr.PopHeaderPanel.superclass.initComponent.call(this);
    }
});


Ext.define('Shr.JsonStore', {
    extend: 'Ext.data.JsonStore',
    url: 'API/JsonFetcher.svc/Invoke'
});
//TEMP BDH START
//Ext.define('Shr.GroupStore', {
//    extend: 'Ext.data.GroupingStore',

//    url: 'API/JsonFetcher.svc/Invoke'
//});
//TEMP BDH END

/**
 * Shr.WebControls.PagingToolbar
 */
Ext.define('Shr.WebControls.PagingToolbar', {
    extend: 'Ext.toolbar.Paging',
    listeners: {
        'render': function () {
            //we do not want to show the refresh button
            this.child('#refresh').hide();
        }
    }
});

//Override the width of the input field used to display and change the current page number.
Ext.define('Ext.toolbar.Paging', {
    override: 'Ext.toolbar.Paging',
    inputItemWidth: 50
});

/**
 * Shr.WebControls.IFrameWindow
 */
Ext.define('Shr.WebControls.IFrameWindow', {
    extend: 'Ext.window.Window',
    initComponent: function () {
        var win = this;
        var config = {
            buttons: [{ text: Shr.LABEL_Close, handler: function () { win.close(); } }],
            width: 800,
            height: 600,
            floating: true,
            fixed: true
        };
        Ext.apply(this, config, this.initialConfig);

        this.callParent(arguments);
    },

    onRender: function () {
        this.bodyCfg = {
            tag: 'iframe',
            frameBorder: '0',
            src: this.src,
            cls: this.bodyCls,
            style: {
                border: '0px none',
                background: '#FFFFFF',
                padding: '10px'
            }
        };

        this.callParent(arguments);
    }
});

/**
 * Shr.WebControls.EmailSender
 */
Ext.define('Shr.WebControls.EmailSender', {
    extend: 'Shr.WebControls.Dialog',
    initComponent: function() {
        var config = {
                        pageUrl:  'API/NonValidatingControlFetcher.aspx',
                        title: Shr.LABEL_SendEmail,
                        sourceControl: 'EmailSender',
                        height: 600,
                        width: 800,
                        modal: true,
                        okText: Shr.LABEL_SendEmail,
                        newWindow: false,
                        showOkCancel: true,
                        postParams: this.postParams,
                        destroyOnUpdate: false
        };
        Ext.apply(this, config, this.initialConfig);
        Shr.WebControls.EmailSender.superclass.initComponent.call(this);
    },
    copyText : function (copyFrom, copyTo) {
        // Delay task until HTML editor is loaded
        var copyTask = new Ext.util.DelayedTask(function(){
           Ext.getCmp(copyTo).setValue(Ext.getDom(copyFrom).innerHTML);
        });
        copyTask.delay(1000);
    }
});

Ext.define('Shr.WebControls.FileUploadLink', {
    extend: 'Ext.form.field.Display',
    alias: 'widget.fileuploadlink',

    displayHeight: 50,
    link: null,
    isImage: false,

    // Ext.form.field.Display overrides
    getRawValue: Ext.emptyFn,
    setRawValue: Ext.emptyFn,

    initComponent: function () {
        // Determine display template based upon whether file is an image or not
        this.fieldSubTpl = (this.isImage)
            ? ['<a href="FileDisplay.aspx?' + this.link + '">' + '<img height="' + this.displayHeight + '" src="FileDisplay.aspx?' + this.link + '">' + '</a>']
            : ['<a href="FileDisplay.aspx?' + this.link + '">' + this.name + '</a>'];

        // Also see if we create an anchor tag or not
        // We do not want to show it for specific tasks (ones that send an attachment, but do not store the attachment)
        if (this.link == 'inSession') {
            this.fieldSubTpl = ['<div>' + this.name + '</div>'];
        }

        this.callParent(arguments);
    }
});

/**
* Shr.WebControls.FileUploadForm
*/
Ext.define('Shr.WebControls.FileUploadForm', {
    extend: 'Ext.FormPanel',
    layout:'auto',
    urlQuery: '',
    displayHeight: 20,
    height: 30,
    linkLabel: 'Link',
    selectFileLabel: 'File',
    selectFileEmptyText: 'Select a file',
    tooltip: '',
    waitMsg: '',
    waitTitle: '',
    removeLabel: '',
    removeMsg: '',
    id: 'FileUploadControl',
    isValid: true,
    readOnly: false,
    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);

        me.fileupload = me.getFileUploadCmp(config);
        me.items = [me.fileupload];

        if (me.showHelpIcon) {
            me.help = Ext.create('Shr.WebControls.Help', me.help);
            me.items.push(me.help);
        }

        me.callParent();
    },
    getFileUploadCmp: function (config) {
        var me = this;

        var fileupload = Ext.create('Ext.form.field.File', {
            emptyText: me.selectFileEmptyText,
            msgTarget: 'side',
            allowBlank: true,
            accept: me.allowedFiles,
            clearOnSubmit: false,
            width: 450,
            readOnly: false,
            name: 'fileUpload',
            buttonText: '',
            buttonConfig: {
                iconCls: 'x-fa fa-upload'
            },
            triggers: {
                clear: {
                    cls: 'x-form-trigger fa-times',
                    weight: -1,
                    hideOnReadOnly: false,
                    hidden: true,
                    handler: function () {

                        Ext.Msg.show({
                            title: 'Remove Picture',
                            message: 'Are you sure you want to delete your picture?',
                            buttons: Ext.Msg.YESNO,
                            icon: Ext.Msg.WARNING,
                            fn: function (btn) {
                                if (btn === 'yes') {
                                    me.deleteFile();
                                } else {
                                }
                            }
                        });

                        

                    }
                },
                preview: {
                    cls: 'x-form-trigger fa-eye',
                    weight: -2,
                    hideOnReadOnly: false,
                    hidden: true,
                    handler: function () {
                        me.downloadFile();                        
                    }
                }
            },
            listeners: {
                change: function (thiss, value, eOpts) {
                    me.uploadFile();                                        
                },
                afterrender: function (thiss) {
                    me.setup();
                }                
            }
        });

        return fileupload;
    },
    setFileLink: function () {
        var me = this,
            preview = me.fileupload.triggers.preview,
            clear = me.fileupload.triggers.clear,
            file = me.file;

        if (file) {
            me.fileupload.setRawValue(file.name);
            clear.show();
            if (!me.urlParams.is) {
                preview.show();
            }
            
            Ext.QuickTips.init();

            if (me.qtip) {
                me.qtip.destroy();
            }

            var ctls = [];
            ctls.push({
                xtype: 'label',
                text: file.name
            });

            if (file.isImage) {
                ctls.push({
                    xtype: 'image',
                    alt: file.name,
                    src: 'API/FileDisplay.aspx?' + file.link,
                    maxHeight: 500,
                    maxWidth: 500,
                    listeners: {
                        load: {
                            element: 'el',
                            fn: function (options) {
                                me.qtip.updateLayout();
                            }
                        }
                    }
                });
            }

            me.qtip = Ext.create('Ext.tip.ToolTip', {
                target: preview.domId,
                showDelay: 0,
                maxHeight:500,
                maxWidth: 500,
                layout:'vbox',
                items: ctls
            });
        } else {
            me.fileupload.setRawValue();
            clear.hide();
            preview.hide();
        }
    },
    uploadFile: function () {
        var me = this;
        if (me.getForm().isValid()) {
            var params = Ext.apply(me.urlParams, {
                action: 'upload',
                allowedTemplateFileExtensionTypes: this.allowedFiles,
                allowedTemplateMaxSizeInBytes: this.maxSizeInBytes
            });
            me.getForm().submit({
                url: 'API/UploadFile.ashx',
                params: params,
                waitMsg: me.resources.waitMsg,
                waitTitle: me.resources.waitTitle,
                failure: function (response, options) {
                    if (options.result.msg != null) {
                        me.resetForm();
                        alert(options.result.msg);
                        return false;
                    }
                },
                success: function (response, options) {
                    me.file = options.result.file;
                    me.setFileLink();
                    me.fireEvent('onProfileModification', me);
                }
            });
        }
    },
    deleteFile: function () {
        var me = this;
        var params = Ext.apply(me.urlParams, {
            action: 'delete'
        });
        me.getForm().submit({
            clientValidation: false,
            url: 'API/UploadFile.ashx',
            params: params,
            waitMsg: me.resources.removeMsg,
            waitTitle: me.resources.waitTitle,
            failure: function (response, options) {
                me.resetForm();
            },
            success: function (response, options) {
                me.file = null;
                me.resetForm();
                me.fireEvent('onProfileModification', me);
            }
        });
    },
    resetForm: function () {
        var me = this;
        me.form.reset();
        me.setFileLink();
    },
    setup: function () {
        var me = this,
            fileupload = me.fileupload;
        if (!me.isValid) {
            fileupload.markInvalid(me.resources.noFileAttachmentMsg);
        }
        if (me.file) {
            me.setFileLink();
        }
    },
    downloadFile: function () {
        var me = this;
        document.location.href = 'API/FileDisplay.aspx?' + me.file.link + '&f=true';
    }
});

Ext.define('Shr.WebControls.Help', {
    extend: 'Ext.button.Button',
    iconCls: 'x-fa fa-question-circle',
    ui: 'help',
    minwidth: 30,

    tooltip: null,
    title: null,
    sourceControl: 'FieldLevelHelp',
    objectName: null,
    columnName: null,
    taskElementKey: null,
    

    type: null,
    handler: function () {
        var me = this;
        var urlParams = Ext.Object.toQueryString({
            ObjectName: me.objectName,
            DatabaseColumnName: me.columnName,
            TaskElementKey: me.taskElementKey
        });

        var dialog = Ext.create('Shr.WebControls.Dialog', {
            title: me.title,
            sourceControl: me.sourceControl,
            urlParams: urlParams
        }).show();
        

    }
});

Ext.define('Shr.WebControls.PropertyGrid', {
    extend: 'Ext.grid.property.Grid',
    alias: 'widget.webcontrolspropertygrid',
    enableColumnMove: false,
    viewconfig: {
        forcefit: true
    },
    initComponent: function() {
        var me = this;
        Shr.WebControls.PropertyGrid.superclass.initComponent.call(this);
        
        me.columns[1].renderer =  me.renderCell;
       // Track changes to the data so we can fire our events.
        me.store.on('update', me.onUpdate, me);

    },
    constructor: function (cfg) {
        var me = this;

        var comboBox = Ext.create('Ext.form.field.ComboBox', {
            selectOnFocus: true,
            typeAhead: true,
            triggerAction: 'all',
            lazyRender: true,
            mode: 'local',
            store: new Ext.data.Store({
                rootProperty: 'items',
                idProperty: 'option',
                fields: ['option', 'value']
            }),
            valueField: 'option',
            displayField: 'value'
        });
        

        Shr.WebControls.PropertyGrid.superclass.constructor.call(this, cfg);

        var locationEditor = Ext.create('widget.LocationSelectorPicker', {
            id: 'textBoxCSF'           
        });

        var resourceEditor = Ext.create('widget.ResourceEditorPicker', {
            id : 'resourceEditorPicker'
        });

        this.editors.list = new Ext.grid.CellEditor({field: comboBox});
        this.editors.resource = new Ext.grid.CellEditor({field: resourceEditor});
        this.editors.location = new Ext.grid.CellEditor({field: locationEditor});
    },

    getCellEditor : function(record, column) {
        var me = this,
            propName = record.data.name,
            val = record.data.value,
            editor = me.getConfigProp(type, 'editor'),
            type = record.data.dataType,
            editors = me.editors;

        // A custom editor was found. If not already wrapped with a CellEditor, wrap it, and stash it back
        // If it's not even a Field, just a config object, instantiate it before wrapping it.
        if (editor) {
            if (!(editor instanceof Ext.grid.CellEditor)) {
                if (!(editor instanceof Ext.form.field.Base)) {
                    editor = Ext.ComponentManager.create(editor, 'textfield');
                }
                editor = me.setConfigProp(propName, 'editor', new Ext.grid.CellEditor({ field: editor }));
            }
        } else if (type) {
            switch (type) {
                case 'date':
                    editor = editors.date;
                    break;
                case 'number':
                    editor = editors.number;
                    break;
                case 'boolean':
                    // Cannot be ".boolean" - YUI hates using reserved words like that
                    editor = me.editors['boolean']; // jshint ignore:line
                    break;
                case 'list':
                    editor = me.editors['list'];
                    if(record.data.items !== null)
                        editor.field.store.loadData(record.data.items);
                    break;
                case 'resource':
                    editor = me.editors['resource'];
                    editor.field.record = record;
                    break;
                case 'location':
                    editor = me.editors['location'];
                    editor.field.record = record;
                    break;
                case 'code':
                    editor = me.getCodeSelect(record, editors);
                    break;
                default:
                    editor = editors.string;
            }
        } else if (Ext.isDate(val)) {
            editor = editors.date;
        } else if (Ext.isNumber(val)) {
            editor = editors.number;
        } else if (Ext.isBoolean(val)) {
            // Cannot be ".boolean" - YUI hates using reserved words like that
            editor = editors['boolean']; // jshint ignore:line
        } else {
            editor = editors.string;
        }

        // Give the editor a unique ID because the CellEditing plugin caches them
        editor.editorId = propName;
        editor.field.column = me.valueColumn;
        return editor;
    },

    getCodeSelect: function (record, editors) {
        var editorId = 'codeSelect' + record.data.sourceBusinessObject;

        if (editors[editorId] != null)
            return editors[editorId];

        var codeSelect = Ext.create('Ext.form.field.ComboBox', {
            showClear: true,
            selectOnFocus: true,
            codeFiltering: true,
            queryMode: 'local',
            valueField: 'Value',
            displayField: 'Name',
            triggers: {
                triggerClear: {
                    cls: 'x-form-clear-trigger',
                    handler: function () {
                        this.clearValue();
                        this.fireEvent('select', this);
                    },
                    scope: 'this'
                }
            },
            store: {
                model: 'ShrWebControlsComboBoxFieldModel',
                autoLoad: true,
                proxy: {
                    type: 'ajax',
                    url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    extraParams: {
                        'svcprovider': 'JsSearchByDataType',
                        'dataType': record.data.sourceBusinessObject
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'items'
                    }
                }
            },

            beforeBlur: function () {

                //if the field can be empty and the user empties it then return
                if (this.showClear == true && this.getRawValue() == '') {
                    this.setValue('');
                    this.setRawValue('');
                    //we purposely return here
                    return;
                }

                //if there is no data in the store then return
                //this usually means that the dropdown has not been selected or the user has not typed anything which loads the store
                if (this.store.getCount() < 1) {
                        this.setValue('');
                        this.setRawValue('');
                        this.clearValue();
                        this.fireEvent('select', this);
                        return;
                    }

                //we have a store with data so...
                var q = this.getRawValue();  //this is the current complete text (name and value)
                var val = this.getValue();

                //see if the value is in the list
                if (val != null)  //if the value is different then we know that val is just the value and not the complete description
                    record = this.findRecord(this.valueField, val); // smiple find

                //if it is not then we reset the selection back to it's previous value
                if (record == false || record == undefined) {
                    //before we set it back we need to reload the unfiltered store 
                    //so the record will position properly
                    this.store.clearFilter();

                    this.store.load({
                        scope: this,
                        callback: function (records, operation, success) {
                            var selModel = this.getPicker().getSelectionModel();
                            var lastSelectedItem = selModel.getLastSelected(); // this is the value of the item

                            if (lastSelectedItem == null || lastSelectedItem.data == null) {
                                lastSelectedItem = this.initialValue;  // if we have no selected item then use the initial value
                            }
                            else {
                                lastSelectedItem = lastSelectedItem.data.Value
                            }
                            record = this.findRecord(this.valueField, lastSelectedItem);
                            if (record != false && record != undefined) {
                                this.setValue(record.data[this.valueField]);
                                this.setRawValue(record.data[this.displayField]);
                            }
                        }
                    });
                }

                if (record != false && record != undefined) {
                    this.setValue(record.data[this.valueField]);
                    this.setRawValue(record.data[this.displayField]);
                }

                if (this.showClear == true && record == false) {
                    this.setValue('');
                    this.setRawValue('');
                }
            }
        });

        editors[editorId] = new Ext.grid.CellEditor({ field: codeSelect });

        return editors[editorId];
    },

    renderCell: function (val, meta, rec) {
        var me = this,
            grid = me.grid,
            renderer = grid.getConfigProp(rec.get(grid.nameField), 'renderer'),
            result = val;

        if (renderer) {
            return renderer.apply(this, arguments);
        }
        
        if (Ext.isDate(val)) {
            result = me.renderDate(val);
        } else if (Ext.isBoolean(val)) {
            result = me.renderBool(val);
        }

        if (rec.data.dataType == 'resource' && val != null) {
            result = rec.data.value.Name;
            meta.attr = 'title="' + result + '"';
        };
        if (rec.data.dataType == 'location' && val != null && val != '') {
            //Note that the value object has two properties (Value and Description)
            result = rec.data.value.Description
            meta.attr = 'title="' + result + '"';
        }
        return Ext.util.Format.htmlEncode(result);
    },
    onPropertyUpdate: function (ds, record, type) {
        if (type == Ext.data.Record.EDIT) {
            var v = record.data.value;
            
            var oldValue = record.modified.value;
            if (this.fireEvent('beforepropertychange', ds, record.id, v, oldValue) !== false) {
                record.commit();
                this.fireEvent('propertychange', ds, record.id, v, oldValue);
            } else {
                record.reject();
            }
        }
    }
});

Ext.define('Shr.WebControls.ResourceEditorPicker', {
        extend: 'Ext.form.field.Picker',
        alias: 'widget.ResourceEditorPicker',
        triggerCls: 'x-fa fa-pencil',
        config: {
            id : 'resourceEditorPicker',
            editable: false,
            triggers: {
                clear: {
                    cls: 'x-form-clear-trigger',
                    handler: function () { this.setValue('delete'); }
                }
            }
        },

        //we need this so we get no errors from PickerControl.cs
        setPickerDialogState: function (showingResults, title, width, height) { 
        },

        onTriggerClick: function (e) {
            var me = this;
            var urlParams = 'PickerId=' +me.id
            var value = me.getValue();

            if (this.record.data.value.Value != null) {
                urlParams += '&Filter=' +this.record.data.value.Value;
            }
            me.pickerDialog = new Shr.WebControls.Dialog({
               title: 'Resource Editor',
                urlParams: urlParams,
                height : 800,
                width: 1000,
                destroyOnClose : true,
                destroyContentOnClose: false,
                showImmediate: true,
                showOkCancel: false,
                whiteBackground: false,
                sourceControl: 'ResourcePicker',
                hasModalPopupWithGridWithTriggerFields: true
            });
            me.pickerDialog.show();
        },

       setValue: function (value, fireEvent) {
           var me = this;
           me.value = me.record.data.value.Value;
           me.setRawValue(me.valueToRaw(me.record.data.value.Value));
           if (value == 'delete')
            {
                me.record.set('value', 'delete');
                me.value = 'delete';
                me.setRawValue(me.valueToRaw(''));
            }
            if (fireEvent == true) {
               me.record.set('value', value);
               me.value = me.record.data.value.Value;
               me.setRawValue(me.valueToRaw(me.record.data.value.Value));
            }
        }
});

Ext.define('Shr.WebControls.LocationSelectorPicker', {
    extend: 'Ext.form.field.Text',
    alias: 'widget.LocationSelectorPicker',
        
    contructor: function(cfg){
        var me = this;
    },
    
    listeners: {
        focus: function() {
            var me = this;
            var isRequired, isNotNull, isReadOnly, isCheckBox, showRequired, defaultRequiredToTrue, propertyFields;
            var currentPropertyRecord = me.record;

            isNotNull = currentPropertyRecord.data.fieldNotNull;
            isCheckBox = currentPropertyRecord.data.fieldIsCheckBox;
            showRequired = true;
            defaultRequiredToTrue = currentPropertyRecord.data.defaultRequiredToTrue

            propertyFields = Shr.TaskEditor.propertySheetStore.data.items;
            for (var i = 0, len = propertyFields.length; i < len; i++) {
                if (propertyFields[i].data.id == 'IsRequired') {
                    isRequired = Shr.TaskEditor.propertySheetStore.data.items[i].data.value;
                }
                if (propertyFields[i].data.id == 'ReadOnly') {
                    isReadOnly = Shr.TaskEditor.propertySheetStore.data.items[i].data.value;
                }
            }

            if (isRequired || isNotNull || isReadOnly || isCheckBox) {
                showRequired = false;
            }
            if (isReadOnly) {
                defaultRequiredToTrue = false;
            }

            var locationEditorDialog = new Shr.WebControls.ShowForLocationSelector({
                // locations: this.record.data.value.Value,
                //showRequired: this.record.data.showRequired;  we are no longer using the code in JsTEGetElementProperties because we need to account
                //for the user changing the property value prior to selecting the CSF button.
                showRequired: showRequired,
                defaultRequiredToTrue: defaultRequiredToTrue,
                editor: this,
                propertySheetRecord: currentPropertyRecord
            });

            locationEditorDialog.show();            
        }
    }
    ,
    setValue: function (value, fireEvent) {
        var me = this;
        if (fireEvent == true) {
            me.record.set('value', value);
            me.callParent(arguments);
            return me;
        }
    }    
});

Ext.define('Shr.WebControls.ShowForLocationSelector', {
    extend: 'Ext.window.Window',
    //basic window properties
    modal: true,
    title: 'Country Specific Field',
    resizable: false,
    width: 410,
    height: 375,
    buttonAlign: 'right',
    taskData: null,
    iterationCode: null,
    store: null,
    locations: null,
    autoScroll: true,
    showRequired: null,
    defaultRequiredToTrue: null,
    floating: true,
    fixed: true,

    //start the creation of the objects in the window
    initComponent: function () {
        var me = this, 
            locations = null;
        //define the data store based on the passed in values which will look like 'LA|true||DEN|false||SEA|true'
        if(this.propertySheetRecord.data.value.Value)
            locations = this.propertySheetRecord.data.value.Value;
        else if(this.propertySheetRecord.data.value)
            locations = this.propertySheetRecord.data.value;

        var showRequired = this.showRequired;
        var defaultRequiredToTrue = this.defaultRequiredToTrue;
        var arrayData = [];
        if (locations !== undefined && locations !== '' && locations !== null) {
            var selectedlocations = locations.split('||');
            for (var i = 0; i < selectedlocations.length; i++) {
                if (selectedlocations.length >= 1) {
                    var selectedlocation = selectedlocations[i].split('|');
                    var boolLocationRequired = false;
                    if (selectedlocation[1].toLowerCase() == 'true')
                        boolLocationRequired = true;
                    arrayData[i] = {CSFCode: selectedlocation[0], RequiredFlag: boolLocationRequired};
                }
            }
        }

        var locationsStore = new Ext.data.ArrayStore({
            data: [],
            fields: ['CSFCode', 'RequiredFlag']
        });


        var checkColumn = new Ext.grid.column.Check({
            header: 'Required',
            dataIndex: 'RequiredFlag',
            width: 75,
            hidden: !showRequired
        });

        var locationListStore = new Ext.data.JsonStore({
            proxy: {
                    type: 'ajax',
                    pageParam: false, //to remove param "page"
                    startParam: false, //to remove param "start"
                    limitParam: false, //to remove param "limit"
                    url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'items'
                    },
                    extraParams: {
                        svcprovider: 'JsSearchByDataType',
                        dataType: 'SysCSF',
                        sortProperty: '',
                        query: '',
                        filter: '',
                        codeFiltering: false,
                        currentValue: '',
                        preFilterName: '',
                        includeDash: true,
                        hideCodes: false,
                        hideInactive: false
                    }            
            },
            rootProperty: 'items',
            autoLoad: true,
            autoDestroy: true,
            fields: [
                { name: 'Name' },
                { name: 'Value'}]
        });
        
        locationEdit = Ext.create('Ext.form.ComboBox', {
            typeAhead: true,
            triggerAction: 'all',
            forceSelection: true,
            store: locationListStore,
            valueField: 'Value',
            displayField: 'Name'
        });

        function GetLocationsRecods(){
            locationListStore.load({
                params: {
                    svcprovider: 'JsSearchByDataType',
                    dataType: 'SysCSF',
                    sortProperty: '',
                    query: '',
                    filter: '',
                    codeFiltering: false,
                    currentValue: '',
                    preFilterName: '',
                    includeDash: true,
                    hideCodes: false,
                    hideInactive: false
                },
                callback: function (result, options, success) {
                    if (success) {
                        return result;
                    } 
                }
            });
                        
        };

        //this is needed to return the description
        function displayTextLabelValue(val) {
            if(val){
                var opts = locationEdit.store.data.items;
                for (var i = 0, len = opts.length; i < len; i++) {
                    if (opts[i].data.Value === val) {
                        return opts[i].data.Name;
                    }
                }
            }
            return null;
        };

        //define the grid
        var locationGridPanel = new Ext.grid.Panel({
            store: locationsStore,
            plugins: new Ext.grid.plugin.CellEditing({
                clicksToEdit: 1
            }),
            columns: [
                {
                    header: 'CSF Code', 
                    width: 300, 
                    name: 'CSFCode', 
                    dataIndex: 'CSFCode', 
                    editor: locationEdit,
                    renderer: displayTextLabelValue
                }, 
                checkColumn
            ],
            selModel: {
                selType: 'cellmodel'
            },
            width: '100%',
            height: 300,
            clicksToEdit: 1,
            //add record buttons
            tbar: [{
                text: 'New',
                iconCls: 'new',
                handler: function () {
                        var gridPanel = locationGridPanel
                        if (gridPanel.editing) {
                            gridPanel.stopEditing();
                        }
                        gridPanel.getStore().add({LocationCode: '', RequiredFlag: defaultRequiredToTrue});
                    }
                },
                {
                    iconCls: 'delete',
                    text: 'Delete',
                    handler: function (grid, rowIndex, colIndex, item, e) {
                        var selectedGridRecord = locationGridPanel.getSelectionModel().getSelected();
                        if (selectedGridRecord) {
                            if (locationGridPanel.editing) {
                                gridPanel.stopEditing();
                            }
                            locationGridPanel.store.remove(selectedGridRecord.items[0])
                        }
                    }
                }]
        });



        //add the grid
        this.items = [locationGridPanel];
        //We need to load the location combo store manually and 'refresh' the grid
        //so that the combo syncs to the location code and displays the description and not the code
        //when the grid first loads.
        locationListStore.load({
            params: {
                svcprovider: 'JsSearchByDataType',
                dataType: 'SysCSF',
                sortProperty: '',
                query: '',
                filter: '',
                codeFiltering: false,
                currentValue: '',
                preFilterName: '',
                includeDash: true,
                hideCodes: false,
                hideInactive: false
            },
            callback: function (r, options, success) {
                if (success) {
                    for (var i = 0; i < arrayData.length; i++) {
                        if (arrayData.length >= 1) {
                            locationGridPanel.getStore().add({CSFCode: arrayData[i].CSFCode, RequiredFlag: arrayData[i].RequiredFlag});
                        }
                    }
                }
            }
        });

        //add buttons to the window
        this.buttons = [{
            text: Ext.MessageBox.buttonText.ok,
            handler: function () {
                //we need to read the grid data and rebuild our string
                var editedLocations = '';
                var gridPanel = locationGridPanel;
                if (gridPanel.editing) {
                    gridPanel.stopEditing();
                }
                for (var i = 0; i < gridPanel.getStore().getCount(); i++) {
                    var rec = gridPanel.store.getAt(i);

                    // we need to be sure that if a new record is added then a location is required                    
                    if (rec.data.CSFCode == '') {
                        Ext.Msg.show({
                            title: 'Country Specific Field',
                            msg: 'A CSF code is required.',
                            buttons: Ext.Msg.OK,
                            icon: Ext.Msg.WARNING
                        });
                        return;
                    }

                    //check for duplicates
                    var countofDups = 0;
                    for (var x = 0; x < gridPanel.getStore().getCount(); x++) {
                        var recToCheck = gridPanel.store.getAt(x);
                        if (recToCheck.data.CSFCode == rec.data.CSFCode) {
                            countofDups += 1
                        }
                    }

                    if (countofDups > 1) {
                        Ext.Msg.show({
                            title: 'Country Specific Field',
                            msg: 'The same CSF code cannot be used more than once.',
                            buttons: Ext.Msg.OK,
                            icon: Ext.Msg.WARNING
                        });
                       return;
                    }

                    editedLocations += rec.data.CSFCode + '|' + rec.data.RequiredFlag.toString().toLowerCase() + '||';
                }
                //strip off the last ||
                if (editedLocations.substr(editedLocations.length - 2) == '||') {
                    editedLocations = editedLocations.substr(0, editedLocations.length - 2);
                }
                //now pass the string back
                this.locations = editedLocations;
                this.fireEvent('save', this);
                //we need a timeout because IE does not always redisplay the property grid value properly after the save
                var me = this;
                setTimeout(function () {
                    me.close();
                    me.destroy();
                }, 50);

            },
            scope: this
        }, {
            text: Ext.MessageBox.buttonText.cancel,
            handler: function () {
                this.close();
                this.destroy();
            },
            scope: this
        }];

        //load the control
        Shr.WebControls.ShowForLocationSelector.superclass.initComponent.apply(this, arguments);

    },
    listeners: {
        save:
        function () {
            if (this.locations == '') {
                this.propertySheetRecord.data.value.Value = this.locations; // to delete
            }
            else {
                this.propertySheetRecord.data.value = this.locations; // to add and edit
            }
            Shr.TaskEditor.PropertyGrid.fireEvent('propertychange', Shr.TaskEditor.propertySheetStore, this.propertySheetRecord.id, this.locations, '');
        },
        close:
        function () {
            Shr.TaskEditor.propertySheetStore.load({
                params: { elementId: Shr.TaskEditor.selectedElId, 
                svcprovider: 'JsTEGetElementProperties',
                rootProperty: 'records',
                totalProperty: 'totalCount'
                }
            });
        }
    }

});

Shr.formatDate = function (value) {
    if (isNaN(value) || Ext.isEmpty(value)) return null;
    return Ext.util.Format.date(value);
}

Shr.formatNumber = function (value, format) {
    return Ext.util.Format.number(value, format);
}

Shr.codeSelectRenderer = function (value, metaData, record, rowIndex, colIndex, store) {
    if (Ext.isEmpty(value) || Ext.isEmpty(value.Name)) {
        return '';
    }
    else {
       
        if (value.Name.indexOf('(' + value.Value + ')') != -1)
            // if the name already contains the value then we do not need to add it again
            return !Ext.isEmpty(value.Value) ? value.Name : null;
        else
            return !Ext.isEmpty(value.Value) ? value.Name + ' (' + value.Value + ')' : null;
    }
}

Shr.updateTaskField = function (draftId, businessObject, recordId, fieldId, value) {
    Ext.Ajax.request({
        url: 'API/JsonFetcher.svc/Invoke',
        params: {
            svcprovider: 'JsUpdateTaskField',
            draftId: draftId,
            businessObject: businessObject,
            recordId: recordId,
            fieldId: fieldId,
            // value will be an object with Value and Name for combo box fields.
            value: !(value == null || Ext.isEmpty(value.Value)) ? value.Value : value
        }
        //        },
        //        success: function (resp) {
        //            alert('successful');
        //        }
    });

}

Shr.showPersonSummary = function (personFullName, personGuid) { 
    new Shr.WebControls.Dialog({
        title: Shr.LABEL_SummaryFor + personFullName,
        sourceControl: 'panels/PersonSummaryPanel.ascx',
        urlParams: 'person=' + personGuid,
        width: 800,
        height: 350,
        whiteBackground: false
        }).show();
};

Shr.runUserRowSecurity = function (RefreshAllPeopleLabel, runUserRowSecurity_ExplanationTitleLabel, runUserRowSecurity_FinishedLabel, lastRanUserRowSecurityJobDate, runUserRowSecurity_ErrorLabel) {
    //first, we need to ask the user if they want to do this
    Ext.Msg.show({
        title: RefreshAllPeopleLabel,
        msg: runUserRowSecurity_ExplanationTitleLabel.replace("{0}", lastRanUserRowSecurityJobDate),
        buttons: Ext.Msg.OKCANCEL,
        fn: function (btn, text) {
            if (btn == 'ok') {
                Ext.getBody().mask(Shr.LABEL_Loading);
                Ext.Ajax.request({
                    url: 'API/JsonFetcher.svc/Invoke',
                    params: {
                        svcprovider: 'JsRunUserRowSecurity'
                    },
                    timeout: 0,
                    success: function (resp) {
                        if (!Ext.isEmpty(resp.responseText))
                        {
                            Ext.getBody().unmask();
                            var result = Ext.decode(resp.responseText);
                            if (result.success == true)
                            {
                                Ext.Msg.show({ title: RefreshAllPeopleLabel, msg: runUserRowSecurity_FinishedLabel, buttons: Ext.Msg.OK, fn: function (btn, text) { if (btn == 'ok') { __doPostBack(); } } });
                            }
                            else
                            {
                                Ext.Msg.show({ title: RefreshAllPeopleLabel, msg: runUserRowSecurity_ErrorLabel, buttons: Ext.Msg.OK, fn: function (btn, text) { if (btn == 'ok') { __doPostBack(); } } });
                            }
                        }
                    }
                });
            }
        },
        icon: Ext.MessageBox.INFO
    });
};

//Group control methods.
//Remove control from home page customize.
Shr.WebControls.RemoveControl = function (config) { 
    Ext.Msg.show({
        title: config.labels.confirmLabelTitle,
        message: config.labels.areYouSureYouWantToRemoveThisModule,
        buttons: Ext.Msg.YESNO,
        icon: Ext.Msg.QUESTION,
        moduleGuid: config.moduleGuid,
        fn: function(btn, arg, eOpts) {
            if (btn === 'yes') {
                eval(__doPostBack("UserHomePageLayoutEditor_EditorAjaxPanel","Remove$" + eOpts.moduleGuid))
            } 
        }
    });
};

//Print control from MyHomePage.
Shr.WebControls.PrintHomePageComponent= function (panelTitle, moduleGuid) { 
        new Shr.WebControls.Dialog({
            title: panelTitle,
            sourceControl: 'Controls/PrintModule.ascx',
            urlParams: 'Module=' + moduleGuid,
            height: 600,
            width: 800,
            newWindow: true,
            resizable: true
        }).show();
};

Shr.WebControls.OpenLink = function (config) { 
    
    var strParams = '';
    for (i = 0; i < config.param.length; i++) {
        if(i > 0)
            strParams += '&'
        var param = config.param[i].split(':');
        strParams += param[0] + '=' + param[1];
    }

    window.open(config.url + '?' + strParams, '_self');
};

Shr.extractURL = function (str) {
    var ret = "";

    if (/"/.test(str)) {
        ret = str.match(/"(.*?)"/)[1];
    } else {
        ret = str;
    }

    return ret;
};

Shr.getURLParameters = function (url) {
    var strParams = url.split('?')[1];
    var arrParams = [];

    if (strParams) {
        var parts = strParams.substring(1).split('&');

        for (var i = 0; i < parts.length; i++) {
            var nv = parts[i].split('=');
            if (!nv[0]) continue;
            arrParams.push({ param: nv[0], value: nv[1] || true });
        }
    }
    return arrParams;
}
Ext.define('Shr.WebControls.TextBox', {
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.ShrTextBox',
    displayMultiLanguage: false,
    constructor: function (cfg) {
        cfg = cfg || {};
        Shr.WebControls.TextBox.superclass.constructor.call(this, cfg);
    },
    initComponent: function () {
        Shr.WebControls.TextBox.superclass.initComponent.call(this);
        var me = this;
        this.layout = 'hbox';
        this.hideLabel = true;
        this.text = Ext.create('Ext.form.field.Text', me.config.configTextbox);
        this.text.msgTarget = 'side';
        this.prevErrorBtn = null;
        this.text.on({
            /*validitychange: function (obj, isValid, eOpts) {
                if (!isValid)
                    me.showError();
                else
                    me.hideError();
            },*/
            blur: function () {
                eval(this.onchange);
            }
        });

        //validate to look for regtext set, else the error text is the default one.
        if(me.config.configTextbox.regexText != null && me.config.configTextbox.regexText != '' && typeof (me.config.configTextbox.regexText) != 'undefined'){
            this.text.invalidText = this.text.regexText;
        }

        this.errorBtn = new Ext.Button({
            iconCls: 'x-fa fa-exclamation-circle red-text',
            style: {
                background: 'transparent',
                border: 0
            },
            tooltip: this.text.invalidText
        });

        Ext.QuickTips.init();
        this.quickContainer = Ext.create('Ext.container.Container', {
            id: 'quickTipContainer_' + me.text.inputId,
            height: 23,
            width: 23
        });

        //validate if after a post-back the value set was incorrect before submitting.
        if( this.text.value != null && this.text.value != '' && typeof (this.text.value) != 'undefined'){
            this.text.validate();
        }

        this.items = [this.text];

        if (this.displayMultiLanguage) {
            this.text.setTriggers({
                triggerMultiLanguage: {
                    cls: 'x-form-trigger fa-pencil',
                    handler: function () { me.win.show(); },
                    hidden: false,
                    hideOnReadOnly: false
                }
            });

            this.store = new Ext.data.JsonStore({
                proxy: {
                    type: 'ajax',
                    pageParam: false, //to remove param "page"
                    startParam: false, //to remove param "start"
                    limitParam: false, //to remove param "limit"
                    url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'records',
                        totalProperty: 'totalCount'
                    },
                    extraParams: {
                        svcprovider: 'JsGetMultiLanguageText',
                        tablerowguid: me.tableRowGuid,
                        tablename: me.tableName,
                        columnname: me.columnName,
                        draftid: me.draftId,
                        sectionid: me.sectionId,
                        fieldid: me.fieldId,
                        isRequired: me.isRequired
                    }
                },
                rootProperty: 'records',
                autoLoad: true,
                autoDestroy: true,
                fields: [
					{ name: 'guid' },
					{ name: 'tableName' },
					{ name: 'columnName' },
					{ name: 'tableRowGuid' },
					{ name: 'languageCode' },
					{ name: 'isRequired' },
					{ name: 'fieldId' },
					{ name: 'sectionId' },
					{ name: 'languageDescription' },
					{ name: 'valueData' },
					{ name: 'isUserLanguage'}]
            });

            this.grid = new Ext.grid.Panel({
                store: this.store,
                autoScroll: true,
                frame: true,
                clicksToEdit: 1,
                selType: 'cellmodel',
                plugins: new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 1
                }),
                columns: [{
                    //id: 'guid',
                    header: 'guid',
                    dataIndex: 'guid',
                    hidden: true
                }, {
                    header: 'tableName',
                    dataIndex: 'tableName',
                    hidden: true
                }, {
                    header: 'columnName',
                    dataIndex: 'columnName',
                    hidden: true
                }, {
                    header: 'tableRowGuid',
                    dataIndex: 'tableRowGuid',
                    hidden: true
                }, {
                    header: 'languageCode',
                    dataIndex: 'languageCode',
                    hidden: true
                }, {
                    header: 'isRequired',
                    dataIndex: 'isRequired',
                    hidden: true
                }, {
                    header: 'fieldId',
                    dataIndex: 'fieldId',
                    hidden: true
                }, {
                    header: 'sectionId',
                    dataIndex: 'sectionId',
                    hidden: true
                }, {
                    header: Shr.LABEL_Language,
                    dataIndex: 'languageDescription',
                    width: 250
                }, {
                    header: Shr.LABEL_Value,
                    dataIndex: 'valueData',
                    width: 400,
                    editor: new Ext.form.TextField({
                        allowBlank: true
                    })
                }]
            }),

			this.win = new Ext.Window({
			    layout: 'fit',
			    closeAction: 'hide',
			    closable: false,
			    modal: true,
			    width: 665,
			    height: 250,
			    floating: true,
			    fixed: true,
			    title: me.config.labels.dialogtitle,
			    items: [this.grid],
			    buttons: [{
			        text: me.config.labels.save,
			        handler: function () {
			            //serialize the records
			            var recordData = [];
			            me.store.each(function (record) {
			                if (record.dirty)
			                    recordData.push(record.data);
			            });

			            Ext.Ajax.request({
			                loadMask: true,
			                url: 'API/JsonFetcher.svc/Invoke',
			                params: {
			                    svcProvider: 'JsUpdateTaskDraftMultiLanguage',
			                    draftId: me.draftId,
			                    records: Ext.util.JSON.encode(recordData)
			                },
			                success: function (resp, options) {
			                    me.store.each(function (record) {
			                        if (record.data.isUserLanguage && me.text != null) {
			                            me.text.setValue(record.data.valueData);
			                        }
			                    });
			                    me.win.hide();
			                }
			            });
			        }
			    }, {
			        text: me.config.labels.cancel,
			        handler: function () {
			            me.win.hide();
			        }
			    }]
			});
        }

        this.items.push(this.quickContainer);

        this.callParent(arguments);
    },
    showError: function () {
        if(this.quickContainer.items.length == 0){
            this.quickContainer.add(this.errorBtn);
        } else {
            this.compareError();
        }
    },
    hideError: function () {
        if(this.quickContainer.items.length > 0){
            this.quickContainer.remove(this.quickContainer.items.items[0], false);
            if(this.prevErrorBtn != null){
                this.quickContainer.add(this.prevErrorBtn);
            }
        }
    },
    compareError: function(){
        if(this.quickContainer.items.items[0] != this.errorBtn){
            this.prevErrorBtn = this.quickContainer.items.items[0];
            this.quickContainer.remove(this.quickContainer.items.items[0], false);
            this.quickContainer.add(this.errorBtn);
        }
    }
});

Ext.define('Shr.WebControls.JsonStore', {
    extend: 'Ext.data.Store',
    alias: 'widget.ShrJsonStore',

    constructor: function (config) {
        var proxyConfig = {
            storeId: config.storeId,
            remoteSort: config.remoteSort,
            proxy: {
                type: 'ajax',
                timeout: config.timeout,
                url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                actionMethods: {
                    read: 'POST'
                },
                reader: {
                    type: 'json',
                    rootProperty: config.rootProperty,
                    remoteSort: true,
                    totalProperty: config.totalProperty
                },
                writer: {
                    type: 'json'
                },
                extraParams: config.extraParams
            },
            autoLoad: true,
            autoDestroy: true,
            fields: config.fields,
            listeners: config.listeners
        };

        Ext.apply(proxyConfig, config);
        this.callParent([proxyConfig]);
    }
});


Ext.define('NestedGrid.overrides.view.Table', {
    override: 'Ext.view.Table',
    checkThatContextIsParentGridView: function (e) {
        var target = Ext.get(e.target);
        var parentGridView = target.up('.x-grid-view');
        if (parentGridView !== null) {
            if (this.el.getId() != parentGridView.getId()) {
                /* event of different grid caused by grids nesting */
                return false;
            } else {
                return true;
            }
        }
        return true;
    },
    processItemEvent: function (record, row, rowIndex, e) {
        if (e.target && !this.checkThatContextIsParentGridView(e)) {
            return false;
        } else {
            return this.callParent([record, row, rowIndex, e]);
        }
    }
});

Ext.define('NestedGrid.ux.RowExpanderGrid', {
    extend: 'Ext.grid.plugin.RowExpander',
    requires: ['Ext.grid.feature.RowBody', 'Ext.grid.plugin.RowExpander', 'Ext.grid.Panel'],

    alias: 'plugin.rowexpandergrid',
    /**
    * @cfg {Object} [configureGrid={}]
    * Add configuration as you add in normal grid creation for inner grid.
    * 
    */
    configureGrid: null,

    setCmp: function (outerGrid) {
        var me = this;
        this.rowBodyTpl = new Ext.XTemplate('<div class="detailData"></div>');
        me.callParent(arguments);

        // <debug>
        if (!me.configureGrid) {
            Ext.Error.raise("The 'gridConfig' config is required and is not defined.");
        }
        // </debug>
    },
    init: function (outerGrid) {
        var me = this;

        //Calling the parent init function of RowExpander
        this.callParent(arguments);
        //Attaching event handler on the gridview's event like  (expandbady/collapsebody)
        outerGrid.getView().on('expandbody', me.addInnerGridOnExpand, me);
        //outerGrid.getView().on('collapsebody',me.removeInnerGridOnCollapse,me);

    },

    addInnerGridOnExpand: function (rowNode, record, expandRow, eOpts) {
        var me = this;
        if (Ext.fly(rowNode).down('.x-grid-view')) {
            return;
        }

        // Resetting the expanded records object of row expander plugin
        me.recordsExpanded[record.internalId] = false;
        //Getting the dom element in which we have to render the inner grid
        var detailData = Ext.DomQuery.select("div.detailData", expandRow);
        //Creating the object of inner grid based upon passed grid config
        var innerGrid = Ext.create('Ext.grid.Panel', me.configureGrid(rowNode, record, expandRow, eOpts));
        //rendering the innerGrid into dom element
        innerGrid.render(detailData[0]);
    }
});

Ext.define('shrSalaryPlancomboboxfieldModel', {
    extend: 'Ext.data.Model',
    idProperty: 'Value', // this is important!  If it is NOT assigned then the combobox will not sync with the current value at load time
    fields: [
    { name: 'Name' },
    { name: 'Value' }],
});

Ext.define('Shr.panel.SalaryPlan.CodeCombobox', {
    extend: 'Ext.form.field.ComboBox',
    alias: 'widget.salaryPlanCodeComobobox',

    constructor: function (config) {
        var me = this;

        me.valueField = 'Value',
        me.displayField = 'Name'
        me.minChars = 0;
        me.matchFieldWidth = false;

        me.store = new Ext.data.JsonStore({
			model: 'shrSalaryPlancomboboxfieldModel',
            proxy: {
                type: 'ajax',
                pageParam: false, //to remove param "page"
                startParam: false, //to remove param "start"
                limitParam: false, //to remove param "limit"
                url: getPathRoot() + '/API/JsonFetcher.svc/Invoke',
                actionMethods: {
                    read: 'POST'
                },
                reader: {
                    type: 'json',
                    rootProperty: 'items'
                },
                extraParams: {
                    svcprovider: 'JsSearchByDataType',
                    dataType: config.dataType,
                    sortProperty: config.sortProperty == null ? '' : config.sortProperty,
                    query: config.lastQuery == null ? '' : config.lastQuery,
                    filter: config.filter == null ? '' : config.filter,
                    codeFiltering: config.codeFiltering,
                    currentValue: config.initialValue == null ? '' : config.initialValue,
                    preFilterName: config.preFilter == null ? '' : config.preFilter,
                    includeDash: config.showDash,
                    hideCodes: true,
                    hideInactive: config.hideInactiveCodes
                }
            },
            rootProperty: 'items',
            autoLoad: true,
            autoDestroy: true
        })

        this.callParent(arguments);
    },
	onLoad: function () {
        if (!this.hasFocus) {
            return;
        }
        this.setPickerWidth();
    },
    //If the picker is shorter the minWidth should be the same as the fields width and also we set the width as string in order to override the 'auto' immediately.
    //If the picker is longer we need to set the pickers width as it's own to let it run trough runLayout.
    setPickerWidth: function () {
        var picker = this.getPicker(),
            fieldWidth = this.bodyEl.getWidth();

        picker.setMinWidth(fieldWidth);
        picker.setWidth('auto');

        if (picker.getWidth() < fieldWidth) {
            picker.setWidth(fieldWidth + 20); // IE and FF need extra padding or else they wrap
        } else {
            picker.setWidth(picker.getWidth() + 20) // IE and FF need extra padding or else they wrap
        }
    },
	getValue: function () {
        var val = this.exporter(Shr.WebControls.ComboBoxField.superclass.getValue.call(this), this.getRawValue());
        if (this.isSameValue(val, this.startValue))
            return this.startValue; // For change detection
        if (val === null || val.Code === null || val.Value === null) return null;
        return val;
    },

    exporter: function (value, display) {
        var ret = {};
        if (value != null && typeof (value) === 'object') {
            ret[this.valueField] = value.Value;
            ret[this.displayField] = value.Name;
            if (display == "[object Object]") {
                this.setRawValue(value.Name);
				this.setValue(value.Value);  // new
            }
        }
        else if (value != this.dataIndex) {
            ret[this.valueField] = value;
            ret[this.displayField] = display;
        }
        else {
            ret = null;
        }
        return ret;
    },

    isSameValue: function (val1, val2) {
        if (typeof (val1) != typeof (val2))
            return false;
        if (val1 == null)
            return val2 == null;
        if (typeof (val1) != 'object')
            return val1 == val2;

        for (var x in val1) {
            if (val1[x] != val2[x])
                return false;
        }
        for (var y in val2) {
            if (val1[y] != val2[y])
                return false;
        }

        return true;
    }
});

Ext.define("Shr.WebControls.Card", {
    extend: "Ext.panel.Panel",
    alias: 'widget.shr.card',
	cls: "Card shadow",
	width: 250,
	height: 150,
	border: 0,
	data: null,
	sourceControl: null,
	initComponent: function () {
		var me = this;
		var data = me.config.data;
		var isPerson = typeof data.fullname != 'undefined';
		
		if(isPerson)
		{
			me.guid = data.guid;
			me.summaryTitle = data.summaryTitle;
            me.height = typeof me.config.height != 'undefined' ? me.config.height : 190;
			
			me.items = [
				Ext.create('Shr.main.toolbar.ProfileDisplay', {
					cls: "CardImage",
					picture: data.pictureSrc != null,
					src: data.pictureSrc,
					size: 80,
					alt: ""
				}),
				{
					border: 0,
					html: "<div class='CardName'><div><span>" + data.fullname + "</span></div></div><div class='CardDescription'>" + data.description + "</div>"
				}
			];

            if (typeof me.config.data.dialogConfig == 'undefined') {
                if (me.sourceControl != null) {
                    me.setListeners({
                        render: function (c) {
                            c.body.on('click', function () {
                                new Shr.WebControls.Dialog({
                                    modal: true,
                                    width: 800,
                                    height: 350,
                                    whiteBackground: false,
                                    showImmediate: false,
                                    title: c.summaryTitle,
                                    sourceControl: c.sourceControl,
                                    urlParams: 'person=' + c.guid
                                }).show();
                            });
                        },
                        scope: this
                    });
                }
            }
            else {
                me.dialogConfig = me.config.data.dialogConfig;
                me.setListeners({
                    render: function (c) {
                        c.body.on('click', function () {
                            new Shr.WebControls.Dialog(c.dialogConfig).show();
                        });
                    },
                    scope: this
                });
            }
		}
		else
        {
            var desc = data.description;
            if (typeof desc == "string" && desc.length > 60)
            {
                desc = desc.substring(0, 60) + "...";
            }

            me.action = data.action;
			me.html = 
                ((data.iconCls == null || data.iconCls == "")
                    ? ""
                    : "<i class='CardImage " + data.iconCls + "'></i><br>")
                + "<div class='CardName'" + (desc.length > 45 ? " style='font-size: 14px;'" : "") + "><div style='border: 0 !important;'><span>" + desc + "</span></div></div>"
                + ((data.path == null || data.path == "")
                    ? ""
                    : "<div class='CardDescription'>" + data.path + "</div>");
			me.setListeners({
			    click: {
			        element: 'body',
			        fn: function () {
			            me.openTask();
                    }
			    }
			});
		}
		
		//load the control
		Shr.WebControls.Card.superclass.initComponent.apply(this, arguments);
	},
	openTask: function () {
	    var me = this,
	        data = me.config.data;
	    if (data.isPersonTask) {
	        if (!data.personSelected) {
	            var contentEl = Ext.getBody().createChild({
	                tag: 'div'
	            });
	            var dialog;
	            contentEl.load({
	                url: 'StandardTaskPopUp.aspx?' + data.urlParams,
	                method: 'GET',
	                params: '',
	                scripts: true,
	                loadMask: true,
	                callback: function (el, success, response, options) {
	                    dialog.show();
	                }
	            });
	            // Remember the original __doPostBack function, because when we
	            // load the new ASP.NET page, it'll overwrite it with a new one!
	            if (__doPostBack) {
	                me.originalDoPostBackFn = __doPostBack;
	            }

	            dialog = Ext.create('Ext.window.Window', {
	                header: false,
	                contentEl: contentEl,
	                modal: true,
	                closable: true,
	                floating: true,
	                fixed: true,
	                resizable: false,
	                height: 250,
	                width: 500,
	                buttons: [{ text: Ext.Msg.buttonText.cancel, iconCls: 'x-fa fa-ban', handler: function () { dialog.close(); } }],
	                listeners: {
	                    close: function () {
	                        if (__doPostBack) {
	                            __doPostBack = me.originalDoPostBackFn;
	                        }
	                        theForm = document.forms['aspnetForm'];
	                    }
	                }
	            });

	            return false;
	        }
	    }
	    Ext.globalEval(data.action);
    }   
});

Ext.define("Shr.WebControls.Search", {
    extend: "Ext.window.Window",
    id: "AdvancedSearch",
    modal: true,
    resizable: false,
    monitorResize: true,
    bodyPadding: 5,
    width: "85%",
    height: "80%",
    floating: true,
    fixed: true,
    store: new Ext.data.JsonStore({
        proxy: {
			type: "ajax",
			url: getPathRoot() + "/API/JsonFetcher.svc/Invoke",
			actionMethods: {
				read: "POST"
			}      
        },
        autoDestroy: true
    }),
    initComponent: function () {
        var me = this;
		var searchControl = Ext.create('Shr.main.toolbar.Search', {
			width: "100%",
			fieldStyle: "font-size: 18px;",
			isAutoSearch: true,
			value: me.originalSearch,
			showResults: function () {
			    me.mask(Shr.LABEL_Loading);
				Ext.getCmp('AdvancedSearch').search(this.value);
			}
		});
		me.items = [searchControl];
		me.search(me.originalSearch);
        Shr.WebControls.Search.superclass.initComponent.apply(this, arguments);
    },
	search: function (text) {
	    var me = this,
	        context = Ext.get("SelectedContext").dom.value;
		me.store.load({
            params: {
                svcprovider: "JsSearch",
                text: text,
                selectedContext: context
            },
            callback: function (r, options, success) {
                if (success) {
                    me.unmask();
                    var response = r[0].data;
                    me.setTitle((response.result != null && typeof response.result.title != "undefined") ? response.result.title : "Search Results");
					
					if(me.mainPanel != null) me.remove(me.mainPanel, true);

                    if(response.message != null && response.message != "") {
                        me.mainPanel = Ext.create("Ext.panel.Panel", {
                            width: "100%",
                            height: "100%",
                            border: 0,
                            defaults: {
                                bodyStyle: "padding: 5px;"
                            },
                            html: response.message
                        });

                        me.add(me.mainPanel);
                        me.updateLayout();
                    }
                    else {
                        var searchResults = response.result.searchResults;
                        var panels = new Array();

                        for (var i = 0; i < searchResults.length; i++) {
                            var panelData = searchResults[i];

                            panels.push(Ext.create("Ext.panel.Panel", {
								width: "100%",
								height: "100%",
								id: panelData.id,
								title: panelData.title,
								collapsed: panelData.totalCount == 0,
								items: me.getPanelItems(panelData, response.result.personSummaryControl),
								html: panelData.totalCount > 0 ? null : response.result.noMatchesFoundLabel
							}));
                        }

                        me.mainPanel = Ext.create("Ext.panel.Panel", {
                            width: "100%",
                            height: me.getHeight() - 100,
                            border: 0,
							scrollable: true,
                            items: [
								Ext.create("Ext.panel.Panel", {
									width: "100%",
									height: "100%",
									border: 0,
									defaults: {
										bodyStyle: "padding: 5px;"
									},
									layout: {
										type: "accordion",
										titleCollapse: true,
										animate: true,
										multi: true,
										fill: false
									},
									items: panels
								})
							]
                        });

                        me.add(me.mainPanel);
                        me.updateLayout();
                    }
                }
            }
        });
	},
    getPanelItems: function (panelData, sourceControl) {
        var records = new Array();

        for (var i = 0; i < panelData.records.length; i++) {
            records.push(Ext.create("Shr.WebControls.Card", {
				data: panelData.records[i],
				sourceControl: sourceControl
            }));
        }
        return records;
    }
});

Ext.define("Shr.WebControls.MenuItems", {
    show: function (menuItems) {
        var me = this;
        var children = new Array();
		for(var i = 0; i < 1 /*menuItems.length*/; i++)
        {
            children.push(me.getItems(menuItems[i], true));
        }

        var isPersonMenu = Ext.getDom("ModuleLayoutPanel_personContainer") != null;

        Ext.create("Ext.panel.Panel", {
            ui: "menu-items",
            id: 'mainmenu',
            width: "99%",
            border: 10,
            style:{
                marginTop: isPersonMenu ? "0" : "20px",
                marginBottom: "20px"
            },
            renderTo: "centerContainer",
            cls: "shadow",
            items: children
        }).updateLayout();
    },
    getItems: function(menuItem, isFirst) {
        var me = this;
        var items = new Array();
		var subPanelItems = new Array();

        if(menuItem.children.length > 0) {
            for(var i = 0; i < menuItem.children.length; i++)
            {
                var item = me.getItems(menuItem.children[i], false);
				
				if(item.$className == "Shr.WebControls.Card") {
					items.push(item);
				}
				else {
					subPanelItems.push(item);
				}
            }
			
			if(subPanelItems.length > 0) {
				items.push(Ext.create("Ext.panel.Panel", {
					width: "100%",
					border: 0,
					bodyStyle: "background: #ececec; padding: 0;",
					items: subPanelItems
				}));
			}

            var icon = menuItem.iconCls != null
                ? "<i class='" + menuItem.iconCls + "'></i> "
                : "";

            return Ext.create("Ext.panel.Panel", {
                ui: "menu-items",
			    width: "100%",
                collapsible: true,
                title: icon + menuItem.description,
			    border: 0,
                bodyStyle: "background: #ececec; padding: 10px 0 10px 10px;",
                style: {
                    top: isFirst ? "0px" : "10px"
                    //left: isFirst ? "0px" : "10px" // we need room from sub-menus
                },
                items: items,
                listeners: {
                    resize: function (cmp) {
                        cmp.updateLayout();
                        cmp.ownerCt.updateLayout();
                    },
                    beforerender: function () {
                        var me = this;
                        if (menuItem.isExpanded == true) {
                            me.collapsed = false;
                        }
                        else if (menuItem.isExpanded == false) {
                            me.collapsed = true;
                        }else
                        {
                            me.collapsed = false; // null case - menuItem.isExpanded == null
                        }
                    },
                    expand: function () {
                        if (menuItem.navigatorGuid != null) {
                            Ext.Ajax.request({
                                url: 'API/JsonFetcher.svc/Invoke',
                                params: {
                                    svcprovider: 'JsUpdateMenuItem',
                                    navigatorGuid: menuItem.navigatorGuid,
                                    isExpanded: true
                                }
                            });
                        }
                    },
                    collapse: function () {
                        if (menuItem.navigatorGuid != null) {
                            Ext.Ajax.request({
                                url: 'API/JsonFetcher.svc/Invoke',
                                params: {
                                    svcprovider: 'JsUpdateMenuItem',
                                    navigatorGuid: menuItem.navigatorGuid,
                                    isExpanded: false
                                }
                            });
                        }
                    }
                }
		    });
        }
        else {
            return Ext.create("Shr.WebControls.Card", {
				width: 270,
                height: 55,
                data: menuItem
            });
        }
    }
});

Ext.define('Shr.panel.Group', {
    extend: 'Ext.panel.Panel',
    manageHeight:false,
    autoScroll: true,
    border: false,
    bodyBorder: false,
    bodyStyle: {
        background: 'white',
        height:'auto'
    },
    style:{
        background:'white'
    },
    bodyPadding: 15,
    componentCls: 'shadow',
    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);
        //do not display shadow class when component does not have header, looks weird when inside other groups.
        //TODO: Use different control if we don't want to show headers.
        if (!me.header) {
            me.componentCls = '';
        }
        me.callParent();
    },
    listeners: {
        afterrender: function (cmp) {
            cmp.body.setHeight(null);
        }
    },
    setHeight: function () {
        this.callParent();
    }
});

Ext.define('Shr.tab.Panel', {
    extend: 'Ext.tab.Panel',
    xtype: 'shr.tab.Panel',
    componentCls:'shadow',
    isRoot:false,
    manageHeight: false,
    margin: 5,
    bodyStyle: {
        background: 'white'
    },
    style: {
        background: 'white'
    },
    defaults:{
        margin: 0,
        border: false,
        bodyBorder: false,        
    },
    border: false,
    bodyBorder: false,
    tabs: [],
    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);
        
        if (me.tabs.length > 0) {            
            me.activeTab = me.getActiveTabIndex(me.tabs);
            me.items = me.getTabItems(me.tabs);
            if(me.tabs[me.activeTab].subTabs.length > 0){
                me.ui = 'parent-tab';
            }
        }
        me.callParent();
    },
    listeners:{
        beforetabchange: function(tabPanel, newCard, oldCard, eOpts ){
            return false;
        }
    },
    getActiveTabIndex: function(tabs){
        for (var i = 0; i < tabs.length; i++) {
            var tab = tabs[i];
            if(tab.selected){
                return i;
            }
            var subtabs = tab.subTabs;
            for (var j = 0; j < subtabs.length; j++) {
                if (subtabs[j].selected) {
                    return i;
                }
            }
        }

    },
    getTabItems:function(tabs, xtype){
        var me = this;

        if (tabs == null || tabs.length <= 0) {
            return null;
        }

        var tabItems = [];
        for (var i = 0; i < tabs.length; i++) {
            var tab = tabs[i];
            var type = tab.subTabs.length > 0 ? 'shr.tab.Panel' : 'panel';
            var tabItem = {
                xtype: type,
                ui: 'child-tab',
                manageHeight: false,
                tabConfig: {
                    value: tab.value,
                    title: tab.text,
                    iconCls: tab.iconCls,
                    tooltip: tab.altText,
                    handler: tab.onClick,
                    //this cls is only used in task editor to drag and drop porposes.
                    userCls: ['dd-task-tab', tab.tabType ]
                }
            };

            if (tab.subTabs.length > 0) {
                tabItem.activeTab = me.getActiveTabIndex(tab.subTabs),
                tabItem.items = me.getTabItems(tab.subTabs, 'panel')
            }
            if (tab.contentEl) {
                tabItem.contentEl = tab.contentEl;
            }
            
            tabItems.push(tabItem);
        }
        return tabItems;
    }
});

Ext.define('Shr.toolbar.Toolbar', {
    extend: 'Ext.toolbar.Toolbar',
    border:0,
    pager:{
        visible: false,
        pageLabel: 'Page',
        ofLabel: 'of {0}'
    },
    getPagingItems: function () {
        var me = this,
            pager = me.pager,
            first = me.pager.firstPage,
            prev = me.pager.previousPage,
            current = me.pager.currentPage,
            next = me.pager.nextPage,
            last = me.pager.lastPage;

        return [{
            itemId: 'first',
            iconCls: Ext.baseCSSPrefix + 'tbar-page-first',
            disabled: first.disabled,
            handler: first.handler,
            scope: me
        }, {
            itemId: 'prev',
            iconCls: Ext.baseCSSPrefix + 'tbar-page-prev',
            disabled: prev.disabled,
            handler: prev.handler,
            scope: me
        },
        '-',
        pager.pageLabel,
        {
            xtype: 'numberfield',
            itemId: 'Page',
            name: current.name,
            cls: Ext.baseCSSPrefix + 'tbar-page-number',
            allowDecimals: false,
            minValue: 1,
            hideTrigger: true,
            enableKeyEvents: true,
            keyNavEnabled: false,
            selectOnFocus: true,
            submitValue: false,
            // mark it as not a field so the form will not catch it when getting fields 
            isFormField: false,
            width: 40,
            margin: '-1 2 3 2',
            value : current.currentPage + 1,
            handler: current.handler,
            listeners: {
                specialkey: function (field, e) {
                    if (e.getKey() == e.ENTER) {
                        field.handler();
                    }
                }
            }
        }, {
            xtype: 'tbtext',
            itemId: 'afterTextItem',
            html: Ext.String.format(pager.ofLabel, pager.pageCount || 1)
        },
        '-',
        {
            itemId: 'next',
            iconCls: Ext.baseCSSPrefix + 'tbar-page-next',
            disabled: next.disabled,
            handler: next.handler,
            scope: me
        }, {
            itemId: 'last',
            iconCls: Ext.baseCSSPrefix + 'tbar-page-last',
            disabled: last.disabled,
            handler: last.handler,
            scope: me
        },
        '-'];
    },
    
    getCommandItems:function(){
        var me = this,
            newCmd = me.commands.new,
            copyCmd = me.commands.copy,
            deleteCmd = me.commands.delete,
            undeleteCmd = me.commands.undelete,
            addOptionCmd = me.commands.addoption;

        newCmd.iconCls = 'x-fa fa-file-o';
        copyCmd.iconCls = 'x-fa fa-files-o';
        deleteCmd.iconCls = 'x-fa fa-trash-o';
        undeleteCmd.iconCls = 'x-fa fa-undo';
        addOptionCmd.iconCls = 'x-fa fa-magic';

        return [newCmd,copyCmd,deleteCmd, undeleteCmd, addOptionCmd];
    },
    getContextItem:function(){
        var me = this,
            context = me.context;
        context.renderTo = undefined;
        var contextItem = {
            xtype: 'comboboxfield'
        };
        Ext.apply(contextItem, context);
        return contextItem;
    },
    initComponent: function(){
        var me = this,
            commandItems = me.getCommandItems(),
            context = me.context;

        var items = [];

        if (me.pager.visible) {
            var pagingItems = me.getPagingItems();            
            items = items.concat(pagingItems);
        }

        items = items.concat(commandItems);
        
        if (context) {
            items.push('-');
            items.push(me.getContextItem())
        }
        me.items = items;

        me.callParent();
    }
    

});

Ext.define('Shr.task.ExtendedListBox', {
    extend: 'Ext.panel.Panel',
    xtype: 'extendedlistbox',
    upcmd: null,
    downcmd: null,
    search: null,
    data: null,

    sectionList: {
        xtype: 'treelist',
        itemId: 'sectionList',
        ui: 'task-section',
        rootVisible: false,
        listeners: {
            itemclick: function (me, record, eOpts) {
                if (record.node.data.onclick) {
                    Ext.getCmp(me.currentIndexID).setValue(me.getStore().root.indexOf(record.node));
                    var previousIndex = me.getSelection().data.index;
                    Ext.getCmp(me.previousIndexID).setValue(previousIndex);
                    record.node.data.onclick();
                }
            }
        }
    },

    constructor: function (config) {
        var me = this,
            sectionlist = me.sectionList,
            toolbarHeight = 0,
            sectionListHeight = 40,
            children = me.prepareData(config.data),
            toolbarItems = me.getToolbarItems(config);


        if (toolbarItems.length > 0) {
            me.tbar = toolbarItems;
            toolbarHeight = 40;
        }

        sectionlist.currentIndexID = config.currentIndexID;
        sectionlist.previousIndexID = config.previousIndexID;
        sectionlist.store = {
            root: {
                text: 'root',
                children: children
            }
        };

        var hidden = {
            xtype: 'hiddenfield',
            id: config.currentIndexID,
            name: config.currentIndexID,
            value: me.selectedIndex
        };

        var hiddenPrevious = {
            xtype: 'hiddenfield',
            id: config.previousIndexID,
            name: config.previousIndexID,
            value: me.previousIndex
        };

        me.minHeight = toolbarHeight + (config.data.length) * 40;
        me.items = [sectionlist, hidden, hiddenPrevious];
        
        me.callParent();
    },
    listeners: {
        afterrender: function (me) {
            me.setSelected();
        },
        resize: function () {
            MainLayout.updateLayout();
        }
    },
    setSelected: function () {
        var me = this,
            sectionList = me.getComponent('sectionList'),
            selected = sectionList.getStore().getRoot().childNodes[me.selected];
        sectionList.setSelection(selected);
    },
    getToolbarItems: function (config) {
        var me = config,
            items = [];
        if (me.search) {
            var textfield = {
                xtype: 'textfield',
                ui: 'header',
                flex: 1,
                inputId: me.search.inputId,
                value: me.search.value,
                triggers: {
                    search: {
                        cls: 'x-fa fa-search',
                        handler: 'filter'
                    },
                    clear: {
                        hidden: me.search.value == null,
                        cls: 'x-fa fa-times',
                        handler: 'clear'
                    }
                },
                listeners:{
                    specialkey: function (field, e) {
                        if (e.getKey() == e.ENTER) {
                            field.filter();
                        }
                    }
                },
                filter: function () {                    
                    eval(me.search.onclick);
                },
                clear: function(){
                    var me = this;
                    me.setValue('');
                    me.filter();
                }
                
            };
            items.push(textfield);
        }

        if (me.upcmd && me.downcmd) {

            var tools = [{
                xtype: 'label',
                text: me.movecaption
            },
            {
                xtype: 'button',
                iconCls: 'x-fa fa-arrow-up',
                handler: function () {
                    eval(me.upcmd);
                }
            },
            {
                xtype: 'button',
                iconCls: 'x-fa fa-arrow-down',
                handler: function () {
                    eval(me.downcmd);
                }
            }];

            items = items.concat(tools);

        }
        return items;
    },
    prepareData: function (data) {
        var me = this,
            children = [];

        if (data && data.length > 0) {
            for (var i = 0; i < data.length; i++) {

                var child = me.prepareItem(data[i]);
                if (data[i].selected) {
                    me.selected = i;
                    me.selectedIndex = data[i].selectedIndex;
                }

                children.push(child);
            }
        }
        return children;
    },
    prepareItem: function (item) {
        var me = this,
            cls = null,
            iconCls = null,
            text = item.text;
        if(item.status){
            if(!item.status.valid){
                iconCls = 'x-fa fa-exclamation-triangle';
            } else if (item.status.deleted) {
                iconCls = 'x-fa fa-ban'
            } else if (item.status.current) {
                iconCls = 'x-fa fa-bolt'
            } else if (item.status.new) {
                iconCls = 'x-fa fa-plus'
            }        
        }

        return {
            text: text,
            onclick: item.onclick,
            leaf: true,
            iconCls: iconCls
        };
    }
});

/* Model classes */
Ext.define('Shr.model.Default', {
    extend: 'Ext.data.Model',
    idProperty: 'Value',
    fields: [
        { name: 'Value', type: 'string', unique: true },
        { name: 'Name', type: 'string' }
    ]
});

Ext.define('Shr.model.AdvancedSearchPerson', {
    extend: 'Ext.data.Model',
    idProperty: 'Guid',
    fields: [
        { name: 'Guid', type: 'string', unique: true },
        { name: 'FullName', type: 'string' },
        { name: 'DisplayName', type: 'string' },
        { name: 'TypeString', type: 'string' },
        { name: 'BadgeId', type: 'string' },
        { name: 'EmployeeId', type: 'string' },
        { name: 'TimeClockId', type: 'string' },
        { name: 'PayrollId', type: 'string' }
    ]
});

/*Picker Controls*/
Ext.define('Shr.WebControls.ButtonPicker', {
    extend: 'Ext.button.Button',
    alias: ['widget.buttonpicker'],
    iconCls: 'x-fa fa-search',
    listeners: {
        adshow: 'onADShow',
        adrecordselect: 'onADRecordSelect',
        adrecorddeselect: 'onADRecordDeselect',
        adselectionchanged: 'onADSelectionChanged',
        adstoreload: 'onADStoreLoad',
    },
    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);
        me.callParent();
    },
    initComponent: function() {
        var me = this;
        me.callParent();
        me.setAdvancedSearch();
    },
    showPickerDialog: function () {
        var urlParams = 'PickerId=' + this.id + '&codeFiltering=' + this.codeFiltering + '&isMultiSelect=' + this.multiSelectPicker;
        if (this.preFilter != null && this.preFilter != '') {
            urlParams += '&prefilter=' + this.preFilter;
        }
        if (this.filter != null && this.filter != '') {
            urlParams += '&filter=' + this.filter;
        }
        if (this.urlParams != null && this.urlParams != '') {
            urlParams += '&' + this.urlParams;
        }

        if (!this.pickerDialog.taskInProgress) {
            this.pickerDialog.urlParams = urlParams;
            this.pickerDialog.show();
        }
    },
        setPickerDialogState: function (showingResults, title, width, height) {
        var ptr = this;
        var toolbar = this.pickerDialog.dialogWindow.getDockedItems(); //get the docked items
        var okButton = toolbar[1].getComponent(0); //get the OK button from the toolbar
        var myFunc;
        if (showingResults) {
            // Change how the dialog works so on clicking OK we won't do
            // a postback, and instead will select the current results.
            myFunc = function () { ptr.selectDialogResult(); };
            okButton.setHandler(myFunc);
        }
        else if (okButton.getText() !== ptr.pickerDialog.closeText) {
            myFunc = function () { ptr.pickerDialog.update('OK'); };
            okButton.setHandler(myFunc);
        }

        this.title = title;
        if (title != null)
            this.pickerDialog.setTitle(title);
        if (width != null)
            this.pickerDialog.setWidth(width);
        if (height != null)
            this.pickerDialog.setHeight(height);
    },
    setDialogResultGrid: function (grid) {
        // Should be associated with the event fired when the results grid for a picker
        // is created client-side to select the first result (in single-select mode) or
        // all results (in multi-select mode). If in single-select and there's only one
        // result, then this is automatically chosen and the picker closes.
        this.resultGrid = grid;
        if (!this.multiSelectPicker) {
            if (grid.getRows().length > 0) {
                grid.setCurrentRow(grid.getRows()[0]);
            }

            var ptr = this;
            if (grid.getRows().length == 1) {
                setTimeout(function () { ptr.selectDialogResult(); }, 250);
            }
        }
        else {
            grid.selectAll();
        }
    },
    setAdvancedSearch: function () {
        var me = this;
        if (me.isDialog) {
            me.advancedSearch = Ext.create('Shr.WebControls.Dialog', {
                title: '',
                destroyOnClose: false,
                showImmediate: false,
                showOkCancel: me.isOkCancel,
                whiteBackground: false,
                sourceControl: me.pickerControl,
                el: Ext.get(this.renderTo),
                open: function () {
                    me.showPickerDialog();
                }
            });
            me.pickerDialog = me.advancedSearch;
            me.setHandler(me.advancedSearch.open);
        } else {
            me.grid = Ext.create(me.pickerControl, {
                multiselect: me.multiSelectPicker,
                resources: me.resources,
                prefilter: me.prefilter,
                listeners: {
                    select: function (grid, record, index, eOpts) { me.fireEvent('adrecordselect', grid, record, index, eOpts); },
                    deselect: function (grid, record, index, eOpts) { me.fireEvent('adrecorddeselect', grid, record, index, eOpts); },
                    selectionchange: function (grid, selected, eOpts) { me.fireEvent('adselectionchanged', grid, selected, eOpts); },
                    storeload: function (store, records, successful, operation, eOpts) { me.fireEvent('adstoreload', store, records, successful, operation, eOpts); },
                }
            });

            me.advancedSearch = Ext.create('Ext.menu.Menu', {
                floating: true,
                width: 850,
                plain: true,
                listeners: {
                    show: function () { me.fireEvent('adshow'); },
                },
                items: [me.grid],
                open: function () {
                    this.showBy(me.el, this.defaultAlign);
                }
            });
            me.setMenu(me.advancedSearch);
        }
    }
});

Ext.define('Shr.WebControls.SinglePicker', {
    extend: 'Ext.form.field.ComboBox',
    alias: ['widget.singlepicker'],
    valueField: 'Value',
    displayField: 'Name',
    queryMode: 'remote',

    anyMatch: true,
    typeAhead: true,
    minChars: 0,

    dataType: null,
    prefilter: null,
    filter: null,
    codeFiltering: null,

    multiSelectPicker: false,
    isDialog: true,


    triggers: {
        clear: {
            cls: 'x-form-clear-trigger',
            handler: function () {
                this.setValue();
                if (this.onchange) {
                    this.onchange();
                }
            },
        },
        search: {
            cls: 'x-fa fa-search',
            handler: function () {
                var me = this;
                me.collapse();
                me.advancedSearch.open();
            },
        }
    },
    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);

        me.setOriginalValue();
        me.setPickerStore();

        me.callParent();
    },
    initComponent: function () {
        var me = this;
        me.callParent();
        me.setAdvancedSearch();
        var store = me.getStore();
        me.selectOriginalValue(store);
        me.setClear(me.value);
        store.on('load', this.onStoreLoad, this);
    },
    listeners: {
        select: 'onSelectPicker',
        adshow: 'onADShow',
        adrecordselect: 'onADRecordSelect',
        adrecorddeselect: 'onADRecordDeselect',
        adselectionchanged: 'onADSelectionChanged',
        adstoreload: 'onADStoreLoad',

        change: function (combo, newValue, oldValue, eOpts) {
            this.setClear(newValue);
            /* This is fired in the onSelectPicker method
            if (this.change) {
                eval(this.change);
            }*/
        }
    },
    /*
     * Picker event methods
     *
     */
    onSelectPicker: function (combo, record, eOpts) {
        combo.setValue();
        combo.select(record);
        var me = this;
        if (me.change) {
            eval(me.change);
        }
        else if (me.onchange)
        {
            me.onchange();
        }
    },
    onStoreLoad: function (store, records, successful, operation, eOpts) {
        var me = this,
            value = me.originalValue;
        if (Ext.isObject(value)) {
            me.selectOriginalValue(store);
        }
    },
    /*
     * Advanced Search events
     */
    onADShow: function () {
        this.updateGrid();
    },
    onADRecordSelect: function (grid, record, index, eOpts) {
        var comboVal = this.findRecordByValue(record.data.Guid);
        if (!comboVal) {
            var newRec = { 'Name': record.data.DisplayName, 'Value': record.data.Guid };
            this.getStore().add(newRec);
        }

        this.select(record.data.Guid);
        if (this.onchange) {
            this.onchange();
        }
    },
    onADRecordDeselect: function (grid, record, index, eOpts) {
    },
    onADSelectionChanged: function (grid, selected, eOpts) {
    },
    onADStoreLoad: function (store, records, successful, operation, eOpts) {
        this.updateGrid();
    },
    /*
     * Configuration methods
     */
    selectOriginalValue: function (store) {
        var me = this;
        //find record by value and if it not exists add it and select it
        if(me.originalValue){
            var val = store.find('Value', me.originalValue.Value);
            if (val < 0) {
                store.insert(0, { Value: me.originalValue.Value, Name: me.originalValue.Name });
            }
            me.setValue();
            me.select(me.originalValue.Value);
            me.expand();    
        }
        
    },
    setClear: function (value) {
        if (!this.showClear)
            this.triggers.clear.setHidden(true);
        else
            if (value) {
                this.triggers.clear.setHidden(false);
            } else {
                this.triggers.clear.setHidden(true);
            }
    },
    setOriginalValue: function () {
        //Setting default value to combobox
        var me = this;
        if (me.value) {
            me.value = {
                Value: me.value,
                Name: me.display
            };
        }
    },
    setPickerStore: function () {
        var me = this;
        me.store = {
            proxy: {
                type: 'ajax',
                url: 'API/JsonFetcher.svc/Invoke',
                actionMethods: {
                    read: 'POST'
                },
                extraParams: {
                    'svcprovider': 'JsSearchByDataType',
                    'dataType': me.dataType,
                    'sortProperty': '',
                    'query': '',
                    'filter': me.filter,
                    'codeFiltering': me.codeFiltering,
                    'currentValue': me.value,
                    'preFilterName': me.prefilter,
                    'includeDash': false,
                    'hideCodes': false,
                    'hideInactive': true
                },
                reader: {
                    type: 'json',
                    rootProperty: 'items'
                }
            },
            remoteFilter: false
        };
    },
    setAdvancedSearch: function () {
        var me = this;
        if (me.isDialog) {
            me.advancedSearch = Ext.create('Shr.WebControls.Dialog', {
                title: '',
                destroyOnClose: false,
                showImmediate: false,
                showOkCancel: me.isOkCancel,
                whiteBackground: false,
                sourceControl: me.pickerControl,
                el: Ext.get(this.renderTo),
                open: function () {
                    me.showPickerDialog();
                }
            });
            me.pickerDialog = me.advancedSearch;
        } else {
            me.grid = Ext.create(me.pickerControl, {
                multiselect: me.multiSelectPicker,
                resources: me.resources,
                prefilter: me.prefilter,
                listeners: {
                    select: function (grid, record, index, eOpts) { me.fireEvent('adrecordselect', grid, record, index, eOpts); },
                    deselect: function (grid, record, index, eOpts) { me.fireEvent('adrecorddeselect', grid, record, index, eOpts); },
                    selectionchange: function (grid, selected, eOpts) { me.fireEvent('adselectionchanged', grid, selected, eOpts); },
                    storeload: function (store, records, successful, operation, eOpts) { me.fireEvent('adstoreload', store, records, successful, operation, eOpts); },
                }
            });

            me.advancedSearch = Ext.create('Ext.menu.Menu', {
                floating: true,
                width: 850,
                plain: true,
                listeners: {
                    show: function () { me.fireEvent('adshow'); },
                },
                items: [me.grid],
                open: function () {
                    this.showBy(me.el, this.defaultAlign);
                }
            });
        }
    },
    updateGrid: function () {
        var me = this,
        grid = me.grid;
        //Deselect all items from advanced search grid and refresh selection.
        grid.getSelectionModel().deselectAll(true);
        if (me.selection) {
            var value = me.selection.data.Value;
            if (value) {
                grid.selectValues([value]);
            }
        }

    },
    showPickerDialog: function () {
        var urlParams = 'PickerId=' + this.id + '&codeFiltering=' + this.codeFiltering + '&isMultiSelect=' + this.multiSelectPicker;
        if (this.preFilter != null && this.preFilter != '') {
            urlParams += '&prefilter=' + this.preFilter;
        }
        if (this.filter != null && this.filter != '') {
            urlParams += '&filter=' + this.filter;
        }
        if (this.urlParams != null && this.urlParams != '') {
            urlParams += '&' + this.urlParams;
        }

        if (!this.pickerDialog.taskInProgress) {
            this.pickerDialog.urlParams = urlParams;
            this.pickerDialog.show();
        }
    },
    setPickerDialogState: function (showingResults, title, width, height) {
        var ptr = this;
        var toolbar = this.pickerDialog.dialogWindow.getDockedItems(); //get the docked items
        var okButton = toolbar[1].getComponent(0); //get the OK button from the toolbar
        var myFunc;
        if (showingResults) {
            // Change how the dialog works so on clicking OK we won't do
            // a postback, and instead will select the current results.
            myFunc = function () { ptr.selectDialogResult(); };
            okButton.setHandler(myFunc);
        }
        else if (okButton.getText() !== ptr.pickerDialog.closeText) {
            myFunc = function () { ptr.pickerDialog.update('OK'); };
            okButton.setHandler(myFunc);
        }

        this.title = title;
        if (title != null)
            this.pickerDialog.setTitle(title);
        if (width != null)
            this.pickerDialog.setWidth(width);
        if (height != null)
            this.pickerDialog.setHeight(height);
    },
    setDialogResultGrid: function (grid) {
        // Should be associated with the event fired when the results grid for a picker
        // is created client-side to select the first result (in single-select mode) or
        // all results (in multi-select mode). If in single-select and there's only one
        // result, then this is automatically chosen and the picker closes.
        this.resultGrid = grid;
        if (!this.multiSelectPicker) {
            if (grid.getRows().length > 0) {
                grid.setCurrentRow(grid.getRows()[0]);
            }

            var ptr = this;
            if (grid.getRows().length == 1) {
                setTimeout(function () { ptr.selectDialogResult(); }, 250);
            }
        }
        else {
            grid.selectAll();
        }
    },
    selectDialogResult: function () {
        var me = this;
        if (!me.multiSelectPicker) {
            var selectedRow = me.resultGrid.getCurrentRow();
            me.setValue(selectedRow.key);
        }

        me.pickerDialog.close();
        me.onChange();
    }
});

Ext.define('Shr.WebControls.MultiPicker', {
    extend: 'Ext.grid.Panel',
    alias: ['widget.multipicker'],
    forceFit: true,

    width: 350,
    height: 330,

    defaultListenerScope: true,
    referenceHolder: true,

    hideHeaders: true,
    showComboBox: true,

    cls: 'x-form-trigger-wrap-default',
    bodyStyle: {
        borderWidth: '1px 0px 1px'
    },
    disableSelection: true,
    value: null,
    selectedValues: [],
    selectBuffer: [],
    deselectBuffer: [],

    valueField: 'Value',
    displayField: 'Name',

    resources: {
        selected: ''
    },

    constructor: function (config) {
        var me = this;
        Ext.apply(me, config);
        me.setHiddenField();
        me.setInitialData();
        me.setToolbar();
        me.callParent();
    },
    initComponent: function () {
        var me = this;
        me.setColumns();
        this.callParent();

    },
    /*
     * Configuration methods
     */
    setInitialData: function () {
        var me = this;
        if (me.value.length > 0) {
            var values = [];
            for (var i = 0; i < me.value.length; i++) {
                values.push(Ext.create('Shr.model.Default', me.value[i]));
            }
            me.store.data = values;
        }
    },
    setHiddenField: function () {
        var value = this.value ? JSON.stringify(this.value) : null;
        this.hiddenValue = Ext.create('Ext.form.field.Hidden', { name: this.hiddenName, value: value, renderTo: this.renderTo });
    },
    setToolbar: function () {
        var me = this;
        if(me.showComboBox){
            me.tbar = [
            {
                xtype: 'singlepicker',
                flex: 1,
                reference: 'combo',
                isDialog: me.isDialog,
                isOkCancel: me.isOkCancel,
                pickerControl: me.pickerControl,
                resources: me.resources,
                multiSelectPicker: true,
                listeners: {
                    adshow: 'onADShow',
                    adrecordselect: 'onADRecordSelect',
                    adrecorddeselect: 'onADRecordDeselect',
                    adselectionchanged: 'onADSelectionChanged',
                    adstoreload: 'onADStoreLoad',
                },
                dataType: me.dataType,
                codeFiltering: me.codeFilternig,
                filter: me.filter,
                prefilter: me.prefilter,
                resources: me.resources,
                selectDialogResult: function () { me.selectDialogResult(); }
            },
            { xtype: 'button', iconCls: 'x-fa fa-trash', handler: 'removeAllRecords' }];

        } else {
            me.tbar = [
            {
                xtype: 'buttonpicker',
                iconCls: 'x-fa fa-search',
                tooltip: me.resources.add,
                reference: 'combo',
                isDialog: me.isDialog,
                isOkCancel: me.isOkCancel,
                pickerControl: me.pickerControl,
                resources: me.resources,
                multiSelectPicker: true,
                listeners: {
                    adshow: 'onADShow',
                    adrecordselect: 'onADRecordSelect',
                    adrecorddeselect: 'onADRecordDeselect',
                    adselectionchanged: 'onADSelectionChanged',
                    adstoreload: 'onADStoreLoad',
                },
                dataType: me.dataType,
                codeFiltering: me.codeFilternig,
                filter: me.filter,
                prefilter: me.prefilter,
                resources: me.resources,
                selectDialogResult: function () { me.selectDialogResult(); }
            },
            '->',
            {
                xtype: 'button', iconCls: 'x-fa fa-trash', tooltip: me.resources.removeallbtn, handler: 'removeAllRecords' }];
        }

        me.bbar = ['->', {
            xtype: 'label',
            reference: 'selectedItems',
            text: me.getSelectedItemsText(me.store.data ? me.store.data.length : 0)
        }, '->'];
    },
    getSelectedItemsText: function (count) {
        var me = this;
        return me.resources.selecteditems.replace('{0}', count);
    },
    setColumns: function () {
        var me = this;
        me.columns = [
        { text: 'person', dataIndex: 'Name' },
        {
            dataIndex: 'action',
            xtype: 'actioncolumn',
            items: [{
                iconCls: 'x-form-clear-trigger',
                handler: 'onRecordRemove'
            }]
        },
        ];
    },
    store: {
        type: 'array',
        model: 'Shr.model.Default',
        sorters: 'Name',
        trackRemoved: false
    },
    addRecord: function (record) {
        var me = this;
        me.store.add(record);
    },
    removeRecord: function (index) {
        var me = this;
        me.store.remove(index);
    },
    removeAllRecords: function () {
        var me = this;
        Ext.Msg.show({
            title: me.resources.removeall,
            message: me.resources.areyousure,
            buttons: Ext.Msg.YESNO,
            fn: function (btn) {
                if (btn === 'yes') {
                    me.store.removeAll();
                    me.updateValue();
                }
            }
        });
    },
    updateGrid: function () {
        var me = this,
            grid = me.getReferences().combo.grid;
        //Deselect all items from advanced search grid and refresh selection.
        grid.getSelectionModel().deselectAll(true);
        grid.selectValues(me.selectedGuids);
    },
    updateValue: function () {
        //save all guids from main grid in values variable and
        //set value as comma separated value for ASP.Net, this will be the server control value.
        var me = this,
            items = me.store.data.items;

        me.selectedValues = [];
        me.selectedGuids = [];
        items.forEach(function (item) {
            me.selectedValues.push(item.data);
            me.selectedGuids.push(item.data.Value);
        });
        me.getReferences().selectedItems.setText(me.getSelectedItemsText(items.length));
        me.hiddenValue.setValue(JSON.stringify(me.selectedValues));
    },
    onSelectPicker: function (combo, record, eOpts) {
        var me = this,
            store = me.getStore(),
            items = store.data.items;
        var match = store.getById(record.data.Value);

        if (match) {
            Ext.toast(me.resources.alreadyselected);
        } else {
            me.addRecord(Ext.create('Shr.model.Default', {
                id: record.data.Value,
                Name: record.data.Name,
                Value: record.data.Value
            }));
            me.updateValue();

        }
        combo.clearValue()
    },
    onRecordRemove: function (grid, rowIndex, colIndex) {
        var store = grid.getStore(),
            record = store.getAt(rowIndex);
        if (record) {
            this.removeRecord(record);
            this.updateValue();
        }
    },

    /*ADVANCED SEARCH GRID LISTENERS*/
    onADShow: function (menu, eOpts) {
        this.updateValue();
        this.updateGrid();
    },
    onADRecordSelect: function (grid, record, index, eOpts) {
        var me = this;
        //Save value to temporary selection before user commits.
        me.selectBuffer.push(record);
    },
    onADRecordDeselect: function (grid, record, index, eOpts) {
        var me = this;
        //Remove deselected value from temporary or already selected values.
        me.deselectBuffer.push(record.data.Guid);
    },
    onADSelectionChanged: function (grid, selected, eOpts) {
        var me = this,
            store = me.getStore();

        //Suspend store events to make the transaction faster.
        store.suspendEvents();

        //Flush selection buffer to main grid.
        if (me.selectBuffer.length > 0) {
            me.selectBuffer.forEach(function (record) {
                me.addRecord(Ext.create('Shr.model.Default', {
                    id: record.data.Guid,
                    Name: record.data.DisplayName,
                    Value: record.data.Guid
                }));
            });
            me.selectBuffer = [];
        }

        //Flush deselection buffer to main grid.
        if (me.deselectBuffer.length > 0) {
            me.deselectBuffer.forEach(function (guid) {
                me.removeRecord(store.getById(guid));
            });
            me.deselectBuffer = [];
        }

        //Resume events and refresh view to be able to see the changes.
        store.resumeEvents();
        me.getView().refresh();

        //update value to retrieve data from ASP.Net
        this.updateValue();
    },
    onADStoreLoad: function (store, records, successful, operation, eOpts) {
        this.updateGrid();
    },

    /*DIALOG SEARCH METHODS*/
    selectDialogResult: function () {
        var me = this,
            store = me.getStore(),
            singlepicker = me.getReferences().combo,
            dialog = singlepicker.pickerDialog,
            selectedRows = singlepicker.resultGrid.getSelectedRows();

        //Suspend store events to make the transaction faster.
        store.suspendEvents();

        selectedRows.forEach(function (record) {
            me.addRecord(Ext.create('Shr.model.Default', {
                id: record.key,
                Name: record.text,
                Value: record.key
            }));
        });

        //Resume events and refresh view to be able to see the changes.
        store.resumeEvents();
        me.getView().refresh();

        dialog.close();
        me.updateValue();
    }

});

Shr.getResources = function (value, callback) {
    Ext.Ajax.request({
        url: 'API/JsonFetcher.svc/Invoke',
        params: {
            svcprovider: 'JsGetResourcesBatch',
            Values: value
        },
        success: function (response,options) {
            var resources = Ext.decode(response.responseText);
            if (callback) {
                callback(resources);
            }            
        },
        failure: function (response, options) {
            //console.log(response);
        }
    });
}

//Ext.define('Shr.AdvancedSearch.Dialog', {
//    extend: 'Shr.WebControls.Dialog',

//    showPickerDialog: function () {
//        var urlParams = {
//            'PickerId': this.id,
//            'codeFiltering': this.codeFiltering,
//            'isMultiSelect': this.multiSelectPicker,
//        };

//        if (Ext.isEmpty(this.preFilter)) {
//            urlParams['prefilter'] = this.preFilter;
//        }
//        if (Ext.isEmpty(this.filter)) {
//            urlParams['filter'] = this.filter;
//        }
//        if (Ext.isEmpty(this.urlParams)) {
//            urlParams['urlParams'] = this.urlParams;
//        }

//        if (!this.taskInProgress) {
//            this.urlParams = urlParams;
//            this.show();
//        }
//    },
//    setPickerDialogState: function () {

//    }

//});

Ext.define('Shr.AdvancedSearch.Person', {
    extend: 'Ext.grid.Panel',
    alias: ['widget.advancedsearch.person', 'widget.personpicker'],
    defaultListenerScope: true,
    referenceHolder: true,    
    height: 400,
    forceFit: true,
    reference: 'grid',
    deferEmptyText: false,
    autoLoad: true,
    resources: {
        filters: 'Filters',
        nodata: 'No Data',
        fullname: 'Full Name',        
        persontype: 'Person Type',
        status: 'Status',
        location: 'Location',
        department: 'Department',
        company: 'Company',
        position: 'Position',
        benefitplan: 'Benefit Plan',
        terminationdate: 'Termination Date',
        supervisor: 'Supervisor',

        firstname: 'First Name',
        lastname: 'Last Name',
        nickname: 'Nick Name',
        formername: 'FormerName',
        badgeid: 'Badge ID',
        employeeid: 'Employee ID',
        timeclockid: 'Time Clock ID',
        personid: 'Person ID',
        nationalid: 'National ID',
        payrollid: 'Payroll ID',

        sqlquery:'SQL'
    },
    temporarySelection: [],
    existingSelection: [],

    constructor:function(config){
        var me = this;
        Ext.apply(me, config);
        Ext.apply(me, {
            viewConfig: {
                emptyText: me.resources.nodata
            },
            store: {
                pageSize: 1000,
                model: 'Shr.model.AdvancedSearchPerson',
                proxy: {
                    autoLoad: true,
                    type: 'ajax',
                    url: 'API/JsonFetcher.svc/Invoke',
                    actionMethods: {
                        read: 'POST'
                    },
                    extraParams: {
                        'svcprovider': 'JsPersonAdvancedSearch',
                        'prefilter': me.prefilter
                    },
                    reader: {
                        type: 'json',
                        rootProperty: 'items'
                    }
                }
            },
            selModel: {
                selType: 'checkboxmodel',
                headerWidth: 32,
                checkOnly: true
            },
            columns: [
                { text: me.resources.fullname, dataIndex: 'FullName', flex: 2 },
                { text: me.resources.badgeid, dataIndex: 'BadgeId', flex: 1 },
                { text: me.resources.employeeid, dataIndex: 'EmployeeId', flex: 1 },
                { text: me.resources.timeclockid, dataIndex: 'TimeClockId', flex: 1 },
                { text: me.resources.payrollid, dataIndex: 'PayrollId', flex: 1 }
            ],
            tbar: {
                xtype: 'toolbar',
                flex: 1,
                hidden: true,
                reference: 'tagstoolbar',
                items: [{
                    xtype: 'tagfield',
                    reference: 'tags',
                    hideTrigger: true,
                    editable: false,
                    selectOnFocus: false,
                    border: 0,
                    expand: Ext.emptyFn,
                    multiSelect: true,
                    flex: 1,
                    valueField: 'id',
                    displayField: 'filter',
                    listeners: {
                        beforedeselect: 'onFilterDeselect'
                    },
                    store: {
                        data: []
                    }
                }]
            },
            bbar: {
                xtype: 'pagingtoolbar',
                displayInfo: true,
                
                emptyText: me.resources.nodata,
                items: [ 
                    {
                        xtype: 'button',
                        text: me.resources.filters,
                        iconCls: 'x-fa fa-filter',
                        menu: {
                            plain: true,
                            bodyPadding: 10,
                            items: [{
                                xtype: 'panel',
                                layout: {
                                    type: 'hbox',
                                    align: 'begin',
                                    pack: 'center'
                                },
                                defaults: {
                                    flex: 1,
                                    margin: 5
                                },
                                items: [{
                                    xtype: 'container', layout: {type:'vbox', align:'end'},
                                    items: [
                                    { xtype: 'filtertextfield', emptyText: me.resources.firstname, dataType: 'FirstName' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.lastname, dataType: 'LastName' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.nickname, dataType: 'NickName' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.formername, dataType: 'FormerLastName' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.badgeid, dataType: 'BadgeId' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.payrollid, dataType: 'PayrollId' },
                                    { xtype: 'filtertextfield', emptyText: me.resources.timeclockid, dataType: 'TimeClockId' }]
                                }, {
                                    xtype: 'container', layout: 'vbox',
                                    defaults: {
                                        listeners: {
                                            change: 'onComboChange'
                                        }
                                    },
                                    items: [
                                        {
                                            xtype: 'combolocal',
                                            emptyText: me.resources.persontype,
                                            minChars: 1,
                                            valueField: 'Value',
                                            displayField: 'Name',
                                            store: {
                                                model: 'Shr.model.Default',
                                                proxy: {
                                                    type: 'ajax',
                                                    url: 'API/JsonFetcher.svc/Invoke',
                                                    actionMethods: {
                                                        read: 'POST'
                                                    },
                                                    extraParams: {
                                                        'svcprovider': 'JsPersonType'
                                                    },
                                                    reader: {
                                                        type: 'json',
                                                        rootProperty: 'records'
                                                    }
                                                }
                                            }
                                        },
                                        { xtype: 'codeselect', emptyText: me.resources.status, dataType: 'Status' },
                                        { xtype: 'codeselect', emptyText: me.resources.location, dataType: 'Location' },
                                        { xtype: 'codeselect', emptyText: me.resources.department, dataType: 'Department' },
                                        { xtype: 'filtertextfield', emptyText: me.resources.nationalid, dataType: 'NationalId'},
                                        { xtype: 'filtertextfield', emptyText: me.resources.personid, dataType: 'PersonId' },
                                        { xtype: 'filtertextfield', emptyText: me.resources.employeeid, dataType: 'EmployeeId' }]
                                },{
                                    xtype:'container',
                                    layout:{
                                        type:'vbox',
                                        align: 'stretch'
                                    },
                                    items:[{
                                        xtype:'fieldset', 
                                        title:'Termination Date', 
                                        layout:'vbox',
                                        margin:'-15px 0px 10px 0px',
                                        padding: '2 10',
                                        items:[{ 
                                            xtype: 'combobox',
                                            reference:'terminationoperator',
                                            emptyText:me.resources.dateoperator,
                                            valueField:'value',
                                            displayField:'value', 
                                            dataType:'TerminationOperation',
                                            store:{
                                                data:[
                                                    {value:'<'},
                                                    {value:'<='}, 
                                                    {value:'='},
                                                    {value:'>='},
                                                    {value: '>'},
                                                    {value: '<>'}] 
                                            },
                                            listeners: {
                                                change: function () {
                                                    var datefield = me.getReferences().terminationdate;
                                                    if (Ext.isDate(datefield.getValue())) {
                                                        me.onDateChange(datefield);
                                                    }                                                    
                                                }
                                            }
                                        }, 
                                        { 
                                            xtype: 'datefield',
                                            reference: 'terminationdate',
                                            hideMode: 'visibility',
                                            emptyText: me.resources.terminationdate,
                                            dataType: 'TerminationDate',
                                            listeners: {
                                                // The collapse event is needed to expand the picker for the first time since it's catching a scroller 
                                                // and closing the picker automatically. This is a workaround to an extjs bug. 
                                                collapse:{
                                                    fn: function (field) {
                                                        field.expand();
                                                    },
                                                    single:true
                                                },
                                                change: function (field, newValue, oldValue, eOpts) {
                                                    if (Ext.isDate(newValue) || !newValue) {
                                                        me.onDateChange(field);
                                                    }
                                                },
                                                select: function (field, value, eOpts) {
                                                    me.onDateChange(field);
                                                }
                                            }
                                        }]
                                    },
                                    { xtype: 'filtercodeselect', emptyText: me.resources.supervisor, dataType: 'Person', preFilter: 'Person_Managers' },
                                    { xtype: 'filtercodeselect', emptyText: me.resources.company, dataType: 'Company' },
                                    { xtype: 'filtercodeselect', emptyText: me.resources.position, dataType: 'Position' },
                                    { xtype: 'filtercodeselect', emptyText: me.resources.benefitplan, dataType: 'BenefitPlan' }]
                                }]
                            }]
                        }
                    }, {
                        xtype: 'button',
                        text: me.resources.sqlquery,
                        iconCls: 'x-fa fa-pencil-square-o', menu: {
                            plain: true,
                            bodyPadding: true,
                            items: [{ xtype: 'textarea', reference:'sqlquery', dataType: 'SqlQuery', fieldLabel: me.resources.sqlquery, width: 400, labelWidth:50 }],
                            tbar: {
                                items: [{
                                    xtype: 'label', html: me.resources.advancedtext, height: 55, padding:5, style: { textAlign:'justify'}}]
                            },
                            rbar: {
                                items: [
                                    { xtype: 'button', text: me.resources.run, handler: 'onSQLRun'},
                                    { xtype: 'button', text: me.resources.remove, handler: 'onSQLClear' }]
                            }
                        }
                    }]
            }
        });
        me.selModel.mode = me.multiselect ? "MULTI" : "SINGLE";
        me.callParent();
    },
    initComponent: function () {
        var me = this;
        this.callParent();

        var store = this.getStore();
        store.on({ load: 'onStoreLoad', scope: this });
    },
    selectValues: function (values) {
        var me = this,
        store = me.getStore(),
        selModel = me.getSelectionModel();
        //Select temporary selection, including values already in field.
        if (values && values.length > 0) {
            for (var i = 0; i < values.length; i++) {
                var rec = store.findExact('Guid', values[i]);
                if (rec >= 0) {
                    selModel.select(rec, true, true);
                }
            }
        }
    },
    onTextDone: function (textfield, event, eOpts) {
        var me = this,
            selection = {
                id: textfield.id,
                value: textfield.value,
                dataType: textfield.dataType,
                filter: textfield.getEmptyText() + ': ' + textfield.value
            };

        //update selected filters
        if(!Ext.isEmpty(textfield.value)){
            me.setFilter(selection);
        } else {
            me.deselectFilter(textfield.id);
        }
        
    },
    onComboChange: function (combo, newValue, oldValue, eOpts) {
        //update selected filters
        var me = this;
        if (newValue) {
            me.setFilter({
                id: combo.id,
                dataType: combo.dataType,
                value: combo.selection.data.Value,
                filter: combo.getEmptyText() + ': ' + combo.selection.data.Name
            });
        } else {
            me.deselectFilter(combo.id);
        }
        
    },
    onDateChange: function(datefield){
        var me = this,
            value = datefield.getValue(),
            operator = me.getReferences().terminationoperator,
            ovalue = (operator.selection || operator.store.data.items[0]).data.value;

        if (Ext.isDate(value)) {
            me.setFilter({
                id: datefield.id,
                dataType: datefield.dataType,
                value: value,
                extraType: operator.dataType,
                extraValue: ovalue,
                filter: datefield.getEmptyText() + ': ' + ovalue +' ' + value.toLocaleDateString()
            });
        } else {
            me.deselectFilter(datefield.id);
        }

    },
    onSQLRun: function(){
        var me = this,
            textarea = me.getReferences().sqlquery,
            selection = {
                id: textarea.id,
                value: textarea.value,
                dataType: textarea.dataType,
                filter: textarea.getFieldLabel() + ': ' + textarea.value
            };

        //update selected filters
        if (!Ext.isEmpty(textarea.value)) {
            me.setFilter(selection);
        } else {
            me.deselectFilter(textarea.id);
        }

    },
    onSQLClear: function(){
        var me = this,
            textarea = me.getReferences().sqlquery;
        textarea.setValue();
        me.deselectFilter(textarea.id);
    },
    onFilterDeselect: function (tags, record, index, eOpts) {
        this.removeFilter(record.id);
    },
    setFilter: function (selection) {
        var me = this,
            gstore = me.getStore(),
            ref = me.getReferences(),
            toolbar = ref.tagstoolbar,
            tags = ref.tags,
            store = tags.getStore(),
            value = tags.getValue(), selected;

        //Show or hide toolbar
        if (toolbar.hidden) {
            toolbar.show();
        }

        //save selection value (combo's id) as selected in tagfield
        if (value.indexOf(selection.id) < 0) {
            value.push(selection.id);
        }

        if (selected = store.getById(selection.value)) {
            selected.data.filter = selection.filter
        } else {
            store.add(selection);
        }

        tags.select(value);

        //add filter paramteres to store and load
        gstore.proxy.extraParams[selection.dataType] = selection.value;
        if (selection.extraType) {
            gstore.proxy.extraParams[selection.extraType] = selection.extraValue;
        }
        gstore.load();
    },    
    deselectFilter: function(id){
        var me = this,
            ref = me.getReferences(),
            tags = ref.tags,
            store = tags.store;
        var value = tags.getValue().filter(function(el) {
            return el !== id;
        });
        tags.setValue(value);
        me.removeFilter(id);

    },
    removeFilter: function (id) {
        var me = this,
            field = Ext.getCmp(id),
            tags = me.getReferences().tags,
            selection = tags.store.getById(id),
            value = tags.getValue(),
            store = me.getStore();

        //hide toolbar if there's no more active filters
        if (value.length < 1) {
            me.getReferences().tagstoolbar.hide();
        }

        //remove the value from the textbox or combobox.
        if (field.clearValue) {
            field.clearValue();
        } else if (field.setValue) {
            field.setValue();
        }

        //remove parameter
        store.proxy.extraParams[field.dataType] = null;
        delete store.proxy.extraParams[field.dataType];

        if (selection && selection.extraValue) {
            //remove parameter
            store.proxy.extraParams[selection.extraValue] = null;
            delete store.proxy.extraParams[selection.extraValue];
        }

        store.load();
    },
    onStoreLoad: function (store, records, successful, operation, eOpts) {
        this.fireEvent('storeload', store, records, successful, operation, eOpts);
    }
});

Ext.define('Shr.WebControls.ComboClear', {
    extend: 'Ext.form.field.ComboBox',
    alias: ['widget.comboclear'],
    triggers: {
        clear: {
            cls: 'x-form-clear-trigger',
            handler: function () { this.clearValue(); }
        }
    },
    initComponent: function () {
        this.callParent();
        this.triggers.clear.hide();
    },
    listeners: {
        change: function (field, newValue, oldValue, eOpts) {
            if (newValue) {
                field.triggers.clear.show();
            } else {
                field.triggers.clear.hide();
            }
        }
    }
});

Ext.define('Shr.WebControls.ComboBoxLocal', {
    extend: 'Shr.WebControls.ComboClear',
    alias: ['widget.combolocal'],
    initComponent: function () {
        var me = this;
        me.callParent();
        var store = me.getStore();
        store.load({
            scope: this,
            callback: function (records, operation, success) {
                me.queryMode = 'local';
            }
        });
    }
});

Ext.define('Shr.WebControls.CodeSelect', {
    extend: 'Shr.WebControls.ComboClear',
    alias: ['widget.codeselect'],

    minChars: 1,

    dataType: null,
    preFilter: null,

    valueField: 'Value',
    displayField: 'Name',
    
    constructor: function (config) {
        var me = this,
            extraParams = me.store.proxy.extraParams;
        extraParams.dataType = config.dataType;
        extraParams.preFilterName = config.preFilter;

        Ext.apply(this, config);
        this.callParent();
    },
    store: {
        model: 'Shr.model.Default',
        proxy: {
            type: 'ajax',
            url: 'API/JsonFetcher.svc/Invoke',
            actionMethods: {
                read: 'POST'
            },
            extraParams: {
                'svcprovider': 'JsSearchByDataType'
            },
            reader: {
                type: 'json',
                rootProperty: 'items'
            }
        }
    }
});

Ext.define('Shr.WebControls.TextClear', {
    extend: 'Ext.form.field.Text',
    alias: ['widget.textclear'],
    triggers: {
        clear: {
            cls: 'x-form-clear-trigger',
            handler: function () { this.setValue(); }
        }
    },
    timeout: null,
    initComponent: function () {
        this.callParent();
        this.setHideTrigger(!this.getValue());
    },
    listeners: {
        change: function (field, newValue, oldValue, eOpts) {
            field.setHideTrigger(!newValue);
            clearTimeout(field.timeout);
            field.timeout = setTimeout(function () {
                field.fireEvent('donetyping', field, newValue);
            }, 500);
        }
    }
});

Ext.define('Shr.WebControls.FilterTextField', {
    extend: 'Shr.WebControls.TextClear',
    alias: 'widget.filtertextfield',
    listeners: {
        donetyping: 'onTextDone'
    }
});

Ext.define('Shr.WebControls.FilterCodeSelectField', {
    extend: 'Shr.WebControls.CodeSelect',
    alias: 'widget.filtercodeselect',
    listeners: {
        change: 'onComboChange'
    }
});

Ext.define('Shr.WebControls.FilterComboField', {
    extend: 'Shr.WebControls.ComboClear',
    alias: 'widget.filtercombofield',
    listeners: {
        change: 'onComboChange'
    }
});


Ext.define('Ext.chart.theme.GraphPanel',{
    extend: 'Ext.chart.theme.Base',
    singleton: true,
    alias: 'chart.theme.graphpanel',
    colors: ['#3F88BC','#FD3A60','#FFA74E',
            '#61A2D0','#FE97AB','#FFB971',
            '#FFA74E','#FA0031','#EE8A25'],
    legend: {
        label: {
            fontSize: 14,
            fontWeight: 'default',
            fontFamily: 'default',
            fillStyle: 'black'
        },
        border: {
            lineWidth: 1,
            radius: 4,
            fillStyle: 'none',
            strokeStyle: 'gray'
        }
    },
    background:'transparent'
});

Ext.define('Shr.panel.Graph', {
    extend: 'Ext.panel.Panel',
    layout: 'center',    
    height: 320,
    cls: 'shr-graph-panel shadow',    
    constructor: function (config) {
        var me = this;
        config = Ext.apply(me, config);
        me.loader = {
            renderer: 'component',
            url: config.source,
            autoLoad: true
        };
        me.callParent(config);
    }
});

Ext.define('Shr.graph.Polar', {
    extend: 'Ext.chart.PolarChart',
    alias: 'widget.shr.polar',
    width:'100%',
    constructor: function (config) {
        var me = this;
        config = Ext.apply(me, config);
        if (me.config.store && me.config.store.proxy) {
            me.config.store.proxy.extraParams = { svcprovider: me.source };
        }
        
        me.callParent(config);
    },
    ui: 'polar-body-panel',
    theme: 'graphpanel',
    height: '100%',
    cls: 'shr-graph-polar',
    innerPadding: 10,
    background: 'rgba(0,0,0,0)',
    store: {
        fields: ['set', 'value'],
        autoLoad: true,
        proxy: {
            type: 'ajax',
            url: 'API/JsonFetcher.svc/Invoke',
            actionMethods: {
                read: 'POST'
            },
            reader: {
                type: 'json',
                rootProperty: 'data'
            }
        }
    },
    interactions: ['rotate'],
    legend: {
        docked: 'left',            
        style: {
            background: 'transparent'
        },
        frame: false,
        border: false
    },
    series: [{
        type: 'pie',
        useDarkerStrokeColor:false,
        animation: {
            easing: 'easeOut',
            duration: 500
        },
        angleField: 'value',  // bind pie slice angular span to market share
        clockwise: false,
        highlight: {
            margin: 10
        },
        label: {
            field: 'set',      // bind label text to name
            display: 'none',
            fontSize: 18
        },
        style: {
            background: 'transparent'
        },
        tooltip: {
            trackMouse: true,
            renderer: function (toolTip, record, ctx) {
                var total = 0,
                    store = record.store,
                    records = store.data.items;

                for (var i = 0; i < records.length; i++) {
                    total += records[i].data.value;
                }

                toolTip.setHtml(record.get('set') + ': ' + record.get('value') + ' ' + Shr.LABEL_Of + ' ' + total);
            },
            calculateTotal: function (store) {
                var records = store.records;
            }
        }
    }]
});

Ext.define('Shr.ToolTip', {
    extend: 'Ext.tip.ToolTip',
    alias: 'widget.shr.tooltip',
    contructor: function (config) {
        var me = this;
        config = Ext.apply(me, config);
        me.callParent(config);
    }
});
